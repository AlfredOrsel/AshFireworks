<!DOCTYPE html>
<html>
<head>
    <title>PixiJS Fireworks - Version 9</title>
    <script src="https://pixijs.download/v7.3.2/pixi.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- UI Controls -->
    <div id="settingsPanel" style="position:fixed;top:10px;left:10px;z-index:1000;color:#fff;font-family:sans-serif;background:rgba(0,0,0,0.6);padding:8px 12px;border-radius:8px;transition:all 0.3s ease;">
        <div style="display:flex;justify-content:flex-start;align-items:center;margin-bottom:8px;">
            <button id="collapseBtn" style="background:none;border:none;color:#fff;cursor:pointer;font-size:16px;padding:2px 6px;border-radius:3px;" title="Collapse Settings">âˆ’</button>
        </div>
        <div id="settingsContent">
            <label>
                Particle count:
                <input type="range" id="particleCountSlider" min="50" max="200" value="120" style="vertical-align:middle;">
                <span id="particleCountValue">120</span>
            </label>
        <label style="margin-left:12px;">
            <input type="checkbox" id="randomParticleCount" style="vertical-align:middle;">
            Random
        </label>
        <br>
        <label>
            Min speed:
            <input type="range" id="minSpeedSlider" min="1" max="10" value="1" step="0.1" style="vertical-align:middle;width:80px;">
            <span id="minSpeedValue">1</span>
        </label>
        <label style="margin-left:12px;">
            Max speed:
            <input type="range" id="maxSpeedSlider" min="1" max="10" value="5" step="0.1" style="vertical-align:middle;width:80px;">
            <span id="maxSpeedValue">5</span>
        </label>
        <br>
        <label>
            <input type="checkbox" id="particleTrailCheckbox" checked>
            Particle trails
        </label>
        <label style="margin-left:12px;">
            <input type="checkbox" id="randomTrailCheckbox">
            Random
        </label>
        <br>
        <label>
            Particle lifetime:
            <input type="range" id="particleLifetimeSlider" min="20" max="80" value="50" style="vertical-align:middle;">
            <span id="particleLifetimeValue">50</span>
        </label>
        <label style="margin-left:12px;">
            <input type="checkbox" id="randomLifetimeCheckbox">
            Random
        </label>
        <br>
        <label>
            Particle gravity:
            <input type="range" id="particleGravitySlider" min="0" max="1" value="0.04" step="0.1" style="vertical-align:middle;width:80px;">
            <span id="particleGravityValue">0.04</span>
        </label>
        <br>
        <label>
            Rocket gravity:
            <input type="range" id="rocketGravitySlider" min="0" max="0.1" value="0.04" step="0.01" style="vertical-align:middle;width:80px;">
            <span id="rocketGravityValue">0.04</span>
        </label>
        <br>
        <label>
            Rocket speed:
            <input type="range" id="rocketSpeedSlider" min="4" max="10" value="8" step="0.1" style="vertical-align:middle;width:80px;">
            <span id="rocketSpeedValue">8</span>
        </label>
        <br>
        <label>
            Explosion trigger (Bottom to top):
            <input type="range" id="explosionTriggerSlider" min="0" max="100" value="50" step="1" style="vertical-align:middle;width:80px;">
            <span id="explosionTriggerValue">50</span>
        </label>
        <label style="margin-left:12px;">
            <input type="checkbox" id="randomExplosionTriggerCheckbox">
            Random
        </label>
        <br>
        <label>
            <input type="checkbox" id="secondaryExplosionCheckbox" checked>
            Secondary explosion particles:
            <input type="range" id="secondaryParticleCountSlider" min="10" max="50" value="25" step="1" style="vertical-align:middle;width:80px;">
            <span id="secondaryParticleCountValue">25</span>
        </label>
        <br>
        <label>Primary particle color:</label>
        <label style="margin-left:8px;">
            <input type="radio" name="primaryParticleColor" id="colorSilver" value="silver" checked> Silver
        </label>
        <label style="margin-left:8px;">
            <input type="radio" name="primaryParticleColor" id="colorGold" value="gold"> Gold
        </label>
        <label style="margin-left:8px;">
            <input type="radio" name="primaryParticleColor" id="colorRandom" value="random"> Random
        </label>
        <label style="margin-left:8px;">
            <input type="radio" name="primaryParticleColor" id="colorMulti" value="multi"> Multi
        </label>
        <br>
        <label>
            <input type="checkbox" id="autoFireToggle"> Auto fire rockets
        </label>
        <label style="margin-left:12px;">
            <input type="checkbox" id="burstModeToggle"> Burst mode
        </label>
        <br>
        <label>
            Auto fire interval:
            <input type="range" id="autoFireIntervalSlider" min="0.2" max="2" value="0.6" step="0.1" style="vertical-align:middle;width:80px;">
            <span id="autoFireIntervalValue">0.6</span>s
        </label>
        <label style="margin-left:12px;">
            Burst rockets:
            <input type="range" id="burstRocketsSlider" min="2" max="10" value="3" step="1" style="vertical-align:middle;width:80px;" disabled>
            <span id="burstRocketsValue">3</span>
        </label>
        <br>
        <button id="startShowBtn" style="margin-top: 8px; padding: 6px 12px; border: none; background: #4CAF50; color: white; border-radius: 4px; cursor: pointer; font-size: 14px;">
            Start Show
        </button>
        </div>
    </div>

    <!-- Collapsed Settings Button -->
    <button id="expandBtn" style="position:fixed;top:18px;left:20px;z-index:1000;display:none;background:none;border:none;color:#fff;cursor:pointer;font-size:16px;padding:2px 6px;border-radius:3px;transition:all 0.3s ease;" title="Expand Settings">+</button>

    <!-- Show JSON Dialog -->
    <div id="showDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2000; background: rgba(0,0,0,0.9); border: 2px solid #444; border-radius: 8px; padding: 20px; width: 600px; max-width: 90vw; max-height: 80vh; color: #fff; font-family: sans-serif;">
        <h3 style="margin-top: 0; color: #4CAF50;">Enter Fireworks Show JSON</h3>
        <textarea id="showJsonInput" style="width: 100%; height: 400px; background: #222; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 10px; font-family: monospace; font-size: 12px; resize: vertical; box-sizing: border-box;" placeholder="Enter your fireworks show JSON here...

Example:
{
  'name': 'My Show',
  'duration': 10,
  'events': [
    {
      'time': 0,
      'type': 'rockets',w
      'count': 5,
      'spread': 800,
      'particleColor': '0xC0C0C0',
      'trailEnabled': true,
      'secondaryExplosion': false
    }
  ]
}"></textarea>
        <div style="margin-top: 15px; text-align: right;">
            <button id="loadExampleBtn" style="margin-right: 10px; padding: 8px 16px; border: none; background: #2196F3; color: white; border-radius: 4px; cursor: pointer;">
                Load Example
            </button>
            <button id="cancelShowBtn" style="margin-right: 10px; padding: 8px 16px; border: none; background: #666; color: white; border-radius: 4px; cursor: pointer;">
                Cancel
            </button>
            <button id="executeShowBtn" style="padding: 8px 16px; border: none; background: #4CAF50; color: white; border-radius: 4px; cursor: pointer;">
                Start Show
            </button>
        </div>
    </div>

    <!-- Dialog Overlay -->
    <div id="dialogOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1999;"></div>
    <script>
        console.log('=== FIREWORKS SCRIPT STARTING ===');
        
        // ================================================
        // FIREWORKS SIMULATION - VERSION 9
        // ================================================

        // User controls
        let particleCount = 120;
        let randomParticleCount = false;
        let minExplosionSpeed = 1;
        let maxExplosionSpeed = 5;
        let particleTrailsEnabled = true;
        let randomParticleTrails = false;
        let particleLifetime = 50;
        let randomParticleLifetime = false;
        let particleGravity = 0.04;
        let rocketGravity = 0.04;
        let rocketSpeed = 8;
        let explosionTriggerPercent = 50;
        let randomExplosionTrigger = false;
        let secondaryParticleCount = 25;
        let secondaryExplosionsEnabled = true;
        let primaryParticleColorMode = "silver";
        let autoFireEnabled = false;
        let burstModeEnabled = false;
        let burstRocketCount = 3;

        const slider = document.getElementById('particleCountSlider');
        const sliderValue = document.getElementById('particleCountValue');
        const randomCheckbox = document.getElementById('randomParticleCount');
        const minSpeedSlider = document.getElementById('minSpeedSlider');
        const maxSpeedSlider = document.getElementById('maxSpeedSlider');
        const minSpeedValue = document.getElementById('minSpeedValue');
        const maxSpeedValue = document.getElementById('maxSpeedValue');
        const particleTrailCheckbox = document.getElementById('particleTrailCheckbox');
        const randomTrailCheckbox = document.getElementById('randomTrailCheckbox');
        const particleLifetimeSlider = document.getElementById('particleLifetimeSlider');
        const particleLifetimeValue = document.getElementById('particleLifetimeValue');
        const randomLifetimeCheckbox = document.getElementById('randomLifetimeCheckbox');
        const particleGravitySlider = document.getElementById('particleGravitySlider');
        const particleGravityValue = document.getElementById('particleGravityValue');
        const rocketGravitySlider = document.getElementById('rocketGravitySlider');
        const rocketGravityValue = document.getElementById('rocketGravityValue');
        const rocketSpeedSlider = document.getElementById('rocketSpeedSlider');
        const rocketSpeedValue = document.getElementById('rocketSpeedValue');
        const explosionTriggerSlider = document.getElementById('explosionTriggerSlider');
        const explosionTriggerValue = document.getElementById('explosionTriggerValue');
        const randomExplosionTriggerCheckbox = document.getElementById('randomExplosionTriggerCheckbox');
        const secondaryParticleCountSlider = document.getElementById('secondaryParticleCountSlider');
        const secondaryParticleCountValue = document.getElementById('secondaryParticleCountValue');
        const secondaryExplosionCheckbox = document.getElementById('secondaryExplosionCheckbox');

        // Primary particle color radio buttons
        document.getElementById('colorSilver').addEventListener('change', (event) => { if (event.target.checked) primaryParticleColorMode = "silver"; });
        document.getElementById('colorGold').addEventListener('change', (event) => { if (event.target.checked) primaryParticleColorMode = "gold"; });
        document.getElementById('colorRandom').addEventListener('change', (event) => { if (event.target.checked) primaryParticleColorMode = "random"; });
        document.getElementById('colorMulti').addEventListener('change', (event) => { if (event.target.checked) primaryParticleColorMode = "multi"; });

        function getPrimaryParticleColor() {
            switch (primaryParticleColorMode) {
                case "silver": return 0xC0C0C0;
                case "gold": return 0xFFD700;
                case "random": return Math.floor(Math.random() * 0xFFFFFF);
                // Remove "multi" from here!
                default: return 0xC0C0C0;
            }
        }

        slider.addEventListener('input', () => {
            particleCount = parseInt(slider.value, 10);
            sliderValue.textContent = particleCount;
        });
        randomCheckbox.addEventListener('change', () => {
            randomParticleCount = randomCheckbox.checked;
        });
        minSpeedSlider.addEventListener('input', () => {
            minExplosionSpeed = parseFloat(minSpeedSlider.value);
            minSpeedValue.textContent = minExplosionSpeed;
            if (minExplosionSpeed > maxExplosionSpeed) {
                maxExplosionSpeed = minExplosionSpeed;
                maxSpeedSlider.value = minExplosionSpeed;
                maxSpeedValue.textContent = minExplosionSpeed;
            }
        });
        maxSpeedSlider.addEventListener('input', () => {
            maxExplosionSpeed = parseFloat(maxSpeedSlider.value);
            maxSpeedValue.textContent = maxExplosionSpeed;
            if (maxExplosionSpeed < minExplosionSpeed) {
                minExplosionSpeed = maxExplosionSpeed;
                minSpeedSlider.value = maxExplosionSpeed;
                minSpeedValue.textContent = maxExplosionSpeed;
            }
        });
        particleTrailCheckbox.addEventListener('change', () => {
            particleTrailsEnabled = particleTrailCheckbox.checked;
        });
        randomTrailCheckbox.addEventListener('change', () => {
            randomParticleTrails = randomTrailCheckbox.checked;
        });
        particleLifetimeSlider.addEventListener('input', () => {
            particleLifetime = parseInt(particleLifetimeSlider.value, 10);
            particleLifetimeValue.textContent = particleLifetime;
        });
        randomLifetimeCheckbox.addEventListener('change', () => {
            randomParticleLifetime = randomLifetimeCheckbox.checked;
        });
        particleGravitySlider.addEventListener('input', () => {
            particleGravity = parseFloat(particleGravitySlider.value);
            particleGravityValue.textContent = particleGravity;
        });
        rocketGravitySlider.addEventListener('input', () => {
            rocketGravity = parseFloat(rocketGravitySlider.value);
            rocketGravityValue.textContent = rocketGravity.toFixed(2);
        });
        rocketSpeedSlider.addEventListener('input', () => {
            rocketSpeed = parseFloat(rocketSpeedSlider.value);
            rocketSpeedValue.textContent = rocketSpeed;
        });
        explosionTriggerSlider.addEventListener('input', () => {
            explosionTriggerPercent = parseInt(explosionTriggerSlider.value, 10);
            explosionTriggerValue.textContent = explosionTriggerPercent;
        });
        randomExplosionTriggerCheckbox.addEventListener('change', () => {
            randomExplosionTrigger = randomExplosionTriggerCheckbox.checked;
        });
        secondaryParticleCountSlider.addEventListener('input', () => {
            secondaryParticleCount = parseInt(secondaryParticleCountSlider.value, 10);
            secondaryParticleCountValue.textContent = secondaryParticleCount;
        });
        secondaryExplosionCheckbox.addEventListener('change', () => {
            secondaryExplosionsEnabled = secondaryExplosionCheckbox.checked;
        });

        // Auto fire toggle
        const autoFireToggle = document.getElementById('autoFireToggle');
        autoFireToggle.addEventListener('change', () => {
            autoFireEnabled = autoFireToggle.checked;
        });

        // Burst mode toggle
        const burstModeToggle = document.getElementById('burstModeToggle');
        burstModeToggle.addEventListener('change', () => {
            burstModeEnabled = burstModeToggle.checked;
            
            // Enable/disable burst rockets slider based on burst mode state
            const burstRocketsSlider = document.getElementById('burstRocketsSlider');
            burstRocketsSlider.disabled = !burstModeEnabled;
        });

        // Burst rockets slider
        const burstRocketsSlider = document.getElementById('burstRocketsSlider');
        const burstRocketsValue = document.getElementById('burstRocketsValue');
        burstRocketsSlider.addEventListener('input', () => {
            burstRocketCount = parseInt(burstRocketsSlider.value, 10);
            burstRocketsValue.textContent = burstRocketCount;
        });

        // Auto fire interval slider
        const autoFireIntervalSlider = document.getElementById('autoFireIntervalSlider');
        const autoFireIntervalValue = document.getElementById('autoFireIntervalValue');
        autoFireIntervalSlider.addEventListener('input', () => {
            autoFireIntervalValue.textContent = autoFireIntervalSlider.value;
        });

        // Show dialog elements
        const startShowBtn = document.getElementById('startShowBtn');
        const showDialog = document.getElementById('showDialog');
        const dialogOverlay = document.getElementById('dialogOverlay');
        const showJsonInput = document.getElementById('showJsonInput');
        const cancelShowBtn = document.getElementById('cancelShowBtn');
        const executeShowBtn = document.getElementById('executeShowBtn');
        const loadExampleBtn = document.getElementById('loadExampleBtn');

        // Load example JSON
        const exampleJSON = {
            "name": "Simple Test Show",
            "duration": 8000,
            "events": [
                {
                    "time": 0,
                    "type": "rockets",
                    "count": 3,
                    "spread": 600,
                    "particleColor": "0xC0C0C0",
                    "trailEnabled": true,
                    "secondaryExplosion": false
                },
                {
                    "time": 2000,
                    "type": "rockets",
                    "count": 5,
                    "spread": 800,
                    "particleColor": "0xFFD700",
                    "trailEnabled": true,
                    "secondaryExplosion": true
                },
                {
                    "time": 4000,
                    "type": "sparkles",
                    "x": 400,
                    "y": 200,
                    "count": 80
                }
            ]
        };

        // Show dialog functionality
        function openShowDialog() {
            showDialog.style.display = 'block';
            dialogOverlay.style.display = 'block';
            showJsonInput.focus();
        }

        function closeShowDialog() {
            showDialog.style.display = 'none';
            dialogOverlay.style.display = 'none';
        }

        // Event listeners for dialog
        startShowBtn.addEventListener('click', openShowDialog);
        cancelShowBtn.addEventListener('click', closeShowDialog);
        dialogOverlay.addEventListener('click', closeShowDialog);
        
        // Load example button
        loadExampleBtn.addEventListener('click', () => {
            showJsonInput.value = JSON.stringify(exampleJSON, null, 2);
        });

        // Execute show button (now with controller logic)
        executeShowBtn.addEventListener('click', () => {
            const jsonText = showJsonInput.value.trim();
            if (jsonText) {
                try {
                    console.log('Raw JSON text:', jsonText);
                    const showData = JSON.parse(jsonText);
                    console.log('Parsed show data:', showData);
                    console.log('Show data type:', typeof showData);
                    console.log('Events property:', showData.events);
                    console.log('Events is array:', Array.isArray(showData.events));
                    
                    // Validate basic structure
                    if (!showData.events) {
                        throw new Error('Show data must have an "events" property');
                    }
                    if (!Array.isArray(showData.events)) {
                        throw new Error('Show data "events" must be an array');
                    }
                    if (showData.events.length === 0) {
                        throw new Error('Show data "events" array cannot be empty');
                    }
                    
                    // Start the timeline controller
                    timelineController.startShow(showData);
                    closeShowDialog();
                } catch (error) {
                    alert('Invalid JSON format or structure. Please check your input.\n\nError: ' + error.message);
                    console.error('JSON parsing error:', error);
                    console.error('Raw input was:', jsonText);
                }
            } else {
                alert('Please enter show JSON data.');
            }
        });

        // Close dialog with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && showDialog.style.display === 'block') {
                closeShowDialog();
            }
        });

        // Settings panel collapse/expand functionality
        const settingsPanel = document.getElementById('settingsPanel');
        const settingsContent = document.getElementById('settingsContent');
        const collapseBtn = document.getElementById('collapseBtn');
        const expandBtn = document.getElementById('expandBtn');

        function collapseSettings() {
            settingsContent.style.display = 'none';
            settingsPanel.style.display = 'none';
            expandBtn.style.display = 'block';
        }

        function expandSettings() {
            settingsContent.style.display = 'block';
            settingsPanel.style.display = 'block';
            expandBtn.style.display = 'none';
        }

        collapseBtn.addEventListener('click', collapseSettings);
        expandBtn.addEventListener('click', expandSettings);

        // Add hover effects via JavaScript
        collapseBtn.addEventListener('mouseenter', () => {
            collapseBtn.style.background = 'rgba(255,255,255,0.1)';
        });
        collapseBtn.addEventListener('mouseleave', () => {
            collapseBtn.style.background = 'none';
        });

        expandBtn.addEventListener('mouseenter', () => {
            expandBtn.style.background = 'rgba(255,255,255,0.1)';
        });
        expandBtn.addEventListener('mouseleave', () => {
            expandBtn.style.background = 'none';
        });

        // Initialize PixiJS
        console.log('=== INITIALIZING PIXIJS ===');
        const app = new PIXI.Application({
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundColor: 0x000000,
            antialias: true
        });
        console.log('=== PIXIJS APP CREATED ===');
        document.body.appendChild(app.view);
        console.log('=== PIXIJS CANVAS ADDED TO BODY ===');

        // FPS Counter
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;

        // Performance monitoring variables
        let baselineParticles = 0;
        let baselineFPS = 60;
        let performanceSamples = [];
        let lastUpdateTime = performance.now();

        // Create FPS display element
        const fpsDisplay = document.createElement('div');
        fpsDisplay.style.cssText = 'position:fixed;top:10px;right:10px;color:#0f0;font-family:monospace;background:rgba(0,0,0,0.7);padding:5px 8px;border-radius:4px;z-index:1001;font-size:14px;font-weight:bold;';
        fpsDisplay.textContent = 'FPS: --';
        document.body.appendChild(fpsDisplay);

        // Create particle count display element
        const particleCountDisplay = document.createElement('div');
        particleCountDisplay.style.cssText = 'position:fixed;top:40px;right:10px;color:#ff0;font-family:monospace;background:rgba(0,0,0,0.7);padding:5px 8px;border-radius:4px;z-index:1001;font-size:14px;font-weight:bold;';
        particleCountDisplay.textContent = 'Particles: 0';
        document.body.appendChild(particleCountDisplay);

        // Create CPU load display element
        const cpuLoadDisplay = document.createElement('div');
        cpuLoadDisplay.style.cssText = 'position:fixed;top:70px;right:10px;color:#0ff;font-family:monospace;background:rgba(0,0,0,0.7);padding:5px 8px;border-radius:4px;z-index:1001;font-size:14px;font-weight:bold;';
        cpuLoadDisplay.textContent = 'CPU: --';
        document.body.appendChild(cpuLoadDisplay);

        // Create GPU load display element
        const gpuLoadDisplay = document.createElement('div');
        gpuLoadDisplay.style.cssText = 'position:fixed;top:100px;right:10px;color:#f0f;font-family:monospace;background:rgba(0,0,0,0.7);padding:5px 8px;border-radius:4px;z-index:1001;font-size:14px;font-weight:bold;';
        gpuLoadDisplay.textContent = 'GPU: --';
        document.body.appendChild(gpuLoadDisplay);

        // Texture creation
        function createCircleTexture(radius, color) {
            const graphic = new PIXI.Graphics();
            graphic.beginFill(color);
            graphic.drawCircle(radius, radius, radius);
            graphic.endFill();
            return app.renderer.generateTexture(graphic);
        }

        // Textures
        const rocketTexture = createCircleTexture(4, 0xFFFFFF);
        const rocketTrailTexture = createCircleTexture(3, 0xFFFFFF);
        const explosionParticleTexture = createCircleTexture(5, 0xFFFFFF);
        const explosionTrailTexture = createCircleTexture(3, 0x888888);

        // Containers - Unlimited for performance testing
        const rocketContainer = new PIXI.Container();
        const explosionContainer = new PIXI.Container();
        app.stage.addChild(rocketContainer);
        app.stage.addChild(explosionContainer);

        // Rocket Trail Class (Version 4 modification)
        class RocketTrail {
            constructor(x, y) {
                this.sprite = new PIXI.Sprite(rocketTrailTexture);
                this.sprite.anchor.set(0.5);
                this.sprite.x = x;
                this.sprite.y = y;
                this.initialSize = 1.5;
                this.sprite.scale.set(this.initialSize);
                this.life = 25;
                this.currentLife = this.life;
                this.sprite.alpha = 0.7;
                rocketContainer.addChild(this.sprite);
            }

            update() {
                this.currentLife--;
                const progress = this.currentLife / this.life;
                this.sprite.scale.set(this.initialSize * progress);
                this.sprite.alpha = progress * 0.7;
                if (this.currentLife <= 0) {
                    rocketContainer.removeChild(this.sprite);
                    return false;
                }
                return true;
            }
        }

        // Rocket Class
        class Rocket {
            constructor(x, targetY) {
                this.sprite = new PIXI.Sprite(rocketTexture);
                this.sprite.anchor.set(0.5);
                this.sprite.x = x;
                this.sprite.y = app.screen.height;
                this.targetY = targetY;
                this.activeTrails = [];
                this.vx = (Math.random() - 0.5) * 2; // random deviation: -1 to +1 px per frame
                
                // Use custom rocket speed if set, otherwise use global setting
                const currentSpeed = this.customRocketSpeed || rocketSpeed;
                this.vy = -currentSpeed; // use configurable upward velocity
                this.initialVy = this.vy; // <-- store initial speed
                
                // Set per-rocket explosion trigger percent
                if (randomExplosionTrigger) {
                    this.explosionTriggerPercent = Math.floor(Math.random() * 101); // 0-100
                } else {
                    this.explosionTriggerPercent = explosionTriggerPercent;
                }
                rocketContainer.addChild(this.sprite);
            }

            addTrail() {
                this.activeTrails.push(new RocketTrail(this.sprite.x, this.sprite.y));
            }

            update() {
                this.sprite.x += this.vx;
                this.sprite.y += this.vy;
                this.vy += rocketGravity;
                this.addTrail();

                for (let i = this.activeTrails.length - 1; i >= 0; i--) {
                    if (!this.activeTrails[i].update()) {
                        rocketContainer.removeChild(this.activeTrails[i].sprite);
                        this.activeTrails.splice(i, 1);
                    }
                }

                // Configurable explosion trigger based on percentage of initial speed
                // 100% = explode immediately, 0% = explode at the top (vy crosses 0)
                let triggerVy = this.initialVy * (1 - this.explosionTriggerPercent / 100);
                if (this.vy > triggerVy) {
                    rocketContainer.removeChild(this.sprite);
                    return false;
                }
                return true;
            }

            updateTrailsOnly() {
                for (let i = this.activeTrails.length - 1; i >= 0; i--) {
                    if (!this.activeTrails[i].update()) {
                        rocketContainer.removeChild(this.activeTrails[i].sprite);
                        this.activeTrails.splice(i, 1);
                    }
                }
                return this.activeTrails.length > 0;
            }
        }

        // Explosion System
        class Explosion {
            constructor(x, y, inheritVx = 0, inheritVy = 0, isSecondary = false, color = null, customProperties = {}) {
                this.particles = [];
                this.trails = [];
                
                // Use custom color if provided, otherwise use default logic
                this.color = color !== null ? color :
                    (customProperties.particleColor !== undefined ? customProperties.particleColor :
                        (!isSecondary ? getPrimaryParticleColor() : Math.random() * 0xFFFFFF));
                
                this.x = x;
                this.y = y;
                this.inheritVx = inheritVx;
                this.inheritVy = inheritVy;
                this.isSecondary = isSecondary;
                
                // Use custom trail setting if provided
                this.trailsEnabled = customProperties.trailEnabled !== undefined ? 
                    customProperties.trailEnabled : 
                    (!isSecondary && particleTrailsEnabled);
                
                if (!isSecondary && randomParticleTrails && customProperties.trailEnabled === undefined) {
                    this.trailsEnabled = Math.random() < 0.5;
                }
                
                this.thisLifetime = particleLifetime;
                if (!isSecondary && randomParticleLifetime) {
                    this.thisLifetime = Math.random() * (particleLifetimeSlider.max - particleLifetimeSlider.min) + parseInt(particleLifetimeSlider.min, 10);
                }
                if (isSecondary) {
                    this.thisLifetime = 40;
                }
                
                // Store custom properties
                this.customParticleCount = customProperties.particleCount;
                this.customSecondaryExplosion = customProperties.secondaryExplosion;
                
                this.initParticles();
            }

            initParticles() {
                let count = this.customParticleCount !== undefined ? 
                    this.customParticleCount : 
                    (this.isSecondary ? secondaryParticleCount : particleCount);
                
                if (!this.isSecondary && randomParticleCount && this.customParticleCount === undefined) {
                    count = Math.floor(Math.random() * (slider.max - slider.min + 1)) + parseInt(slider.min, 10);
                }
                for (let i = 0; i < count; i++) {
                    const p = new PIXI.Sprite(explosionParticleTexture);
                    // Assign random color per particle for multi mode, otherwise use this.color
                    if (!this.isSecondary && primaryParticleColorMode === "multi") {
                        p.tint = Math.floor(Math.random() * 0xFFFFFF);
                    } else {
                        p.tint = this.color;
                    }
                    p.anchor.set(0.5);
                    p.x = this.x;
                    p.y = this.y;
                    const angle = Math.random() * Math.PI * 2;
                    let speed = Math.random() * (maxExplosionSpeed - minExplosionSpeed) + minExplosionSpeed;
                    if (this.isSecondary) {
                        speed *= 0.5;
                    }
                    p.vx = Math.cos(angle) * speed + this.inheritVx * 0.5;
                    p.vy = Math.sin(angle) * speed + this.inheritVy * 0.5;
                    p.scale.set(this.isSecondary ? 0.3 : 0.5);
                    p.life = this.thisLifetime;
                    p.maxLife = this.thisLifetime;
                    p.hasSpawnedSecondary = false;
                    explosionContainer.addChild(p);
                    this.particles.push(p);
                }
            }

            addParticleTrail(particle) {
                if (!this.trailsEnabled) return;
                const trail = new PIXI.Sprite(explosionTrailTexture);
                trail.tint = particle.tint; // Use the particle's color
                trail.alpha = particle.alpha;
                trail.anchor.set(0.5);
                trail.x = particle.x;
                trail.y = particle.y;
                trail.scale.set(particle.scale.x * 0.9);
                trail.life = 10;
                explosionContainer.addChild(trail);
                this.trails.push(trail);
            }

            update() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    this.addParticleTrail(p);

                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += particleGravity;
                    p.life--;
                    p.alpha = p.life / p.maxLife;

                    // When particle fades out, spawn secondary explosion if not already done and not a secondary
                    const shouldCreateSecondary = this.customSecondaryExplosion !== undefined ? 
                        this.customSecondaryExplosion : 
                        secondaryExplosionsEnabled;
                    
                    if (
                        shouldCreateSecondary &&
                        !this.isSecondary &&
                        !p.hasSpawnedSecondary &&
                        p.life <= 0
                    ) {
                        explosions.push(new Explosion(p.x, p.y, 0, 0, true, this.color)); // Pass parent's color
                        p.hasSpawnedSecondary = true;
                    }

                    if (p.life <= 0) {
                        explosionContainer.removeChild(p);
                        this.particles.splice(i, 1);
                    }
                }

                for (let i = this.trails.length - 1; i >= 0; i--) {
                    const t = this.trails[i];
                    t.life--;
                    t.alpha -= 0.04;
                    if (t.alpha <= 0) {
                        explosionContainer.removeChild(t);
                        this.trails.splice(i, 1);
                    }
                }
                return this.particles.length > 0 || this.trails.length > 0;
            }
        }

        // Sparkle Cloud Class
        class SparkleCloud {
            constructor(x, y, count = 120) {
                this.sparkles = [];
                for (let i = 0; i < count; i++) {
                    const s = new PIXI.Sprite(explosionParticleTexture);
                    s.tint = 0xFFFFFF;
                    s.anchor.set(0.5);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 0.7 + 0.2; // very slow for cloud
                    s.vx = Math.cos(angle) * speed;
                    s.vy = Math.sin(angle) * speed;
                    
                    // Position sparkles as if they've already traveled for 40 frames
                    const startRadius = 40 * speed; // distance they would have traveled in 40 frames
                    s.x = x + Math.cos(angle) * startRadius;
                    s.y = y + Math.sin(angle) * startRadius;
                    
                    s.life = 2 * (80 + Math.random() * 40); // double the previous lifetime
                    s.maxLife = s.life;
                    s.scale.set(0.3 + Math.random() * 0.08); // same as secondary
                    s.alpha = 1; // Start visible since they're already spread out
                    explosionContainer.addChild(s);
                    this.sparkles.push(s);
                }
            }
            update() {
                for (let i = this.sparkles.length - 1; i >= 0; i--) {
                    const s = this.sparkles[i];
                    s.x += s.vx;
                    s.y += s.vy;
                    s.life--;

                    // Appear immediately and flicker
                    s.alpha = Math.max(0, (s.life / s.maxLife));
                    // Intense flicker: randomly fully on or off
                    s.alpha = Math.random() < 0.5 ? s.alpha : 0;
                    s.scale.set(0.25 + Math.random() * 0.15);

                    if (s.life <= 0) {
                        explosionContainer.removeChild(s);
                        this.sparkles.splice(i, 1);
                    }
                }
                return this.sparkles.length > 0;
            }
        }

        // Management systems
        const activeRockets = [];
        const fadingTrails = [];
        const explosions = [];
        const sparkleClouds = [];

        function launchRocket() {
            const x = Math.random() * app.screen.width;
            const targetY = Math.random() * app.screen.height * 0.6;
            activeRockets.push(new Rocket(x, targetY));
        }

        // Timeline-based show controller
        class TimelineController {
            constructor() {
                this.isRunning = false;
                this.startTime = 0;
                this.currentShow = null;
                this.eventIndex = 0;
            }

            startShow(showData) {
                this.currentShow = showData;
                this.isRunning = true;
                this.startTime = Date.now();
                this.eventIndex = 0;
                console.log('Starting fireworks show:', showData.name);
                
                // Disable auto fire during show
                autoFireEnabled = false;
                if (autoFireToggle) {
                    autoFireToggle.checked = false;
                }
            }

            stopShow() {
                this.isRunning = false;
                this.currentShow = null;
                this.eventIndex = 0;
                console.log('Stopped fireworks show');
            }

            update() {
                if (!this.isRunning || !this.currentShow) return;

                const elapsedTime = Date.now() - this.startTime; // Keep in milliseconds
                const events = this.currentShow.events;

                // Process all events that should have triggered by now
                while (this.eventIndex < events.length && events[this.eventIndex].time <= elapsedTime) {
                    this.processEvent(events[this.eventIndex]);
                    this.eventIndex++;
                }

                // Check if show is complete
                if (this.eventIndex >= events.length) {
                    this.stopShow();
                }
            }

            processEvent(event) {
                console.log('Processing event:', event);
                
                switch (event.type) {
                    case 'rockets':
                        this.launchRockets(event);
                        break;
                    case 'sparkles':
                        this.createSparkles(event);
                        break;
                    case 'pause':
                        // Pause events are handled by the timeline itself
                        break;
                    default:
                        console.warn('Unknown event type:', event.type);
                }
            }

            launchRockets(event) {
                const count = event.count || 1;
                const spread = event.spread || app.screen.width;
                const startX = event.startX || (app.screen.width - spread) / 2;
                
                for (let i = 0; i < count; i++) {
                    let x;
                    if (count === 1) {
                        x = startX + spread / 2;
                    } else {
                        x = startX + (i * spread) / (count - 1);
                    }
                    
                    const targetY = event.targetY || Math.random() * app.screen.height * 0.6;
                    
                    // Create rocket with custom properties
                    const rocket = new Rocket(x, targetY);
                    
                    // Apply event-specific properties
                    if (event.particleColor !== undefined) {
                        rocket.customParticleColor = this.parseColor(event.particleColor);
                    }
                    if (event.particleCount !== undefined) {
                        rocket.customParticleCount = event.particleCount;
                    }
                    if (event.rocketSpeed !== undefined) {
                        rocket.customRocketSpeed = event.rocketSpeed;
                    }
                    if (event.trailEnabled !== undefined) {
                        rocket.customTrailEnabled = event.trailEnabled;
                    }
                    if (event.secondaryExplosion !== undefined) {
                        rocket.customSecondaryExplosion = event.secondaryExplosion;
                    }
                    
                    activeRockets.push(rocket);
                }
            }

            createSparkles(event) {
                const x = event.x || Math.random() * app.screen.width;
                const y = event.y || Math.random() * app.screen.height;
                const count = event.count || 50;
                
                sparkleClouds.push(new SparkleCloud(x, y, count));
            }

            parseColor(colorValue) {
                if (typeof colorValue === 'string') {
                    // Handle hex string like "0xFFFFFF"
                    if (colorValue.startsWith('0x')) {
                        return parseInt(colorValue, 16);
                    }
                    // Handle regular hex string like "#FFFFFF"
                    if (colorValue.startsWith('#')) {
                        return parseInt(colorValue.substring(1), 16);
                    }
                }
                // If it's already a number, return as is
                return colorValue;
            }
        }

        // Create timeline controller instance
        const timelineController = new TimelineController();

        // Better performance monitoring functions
        function estimateSystemLoad() {
            // Count current particles
            let totalParticles = 0;
            explosions.forEach(explosion => {
                totalParticles += explosion.particles.length;
                totalParticles += explosion.trails.length;
            });
            sparkleClouds.forEach(cloud => {
                totalParticles += cloud.sparkles.length;
            });
            activeRockets.forEach(rocket => {
                totalParticles += rocket.activeTrails.length;
            });
            fadingTrails.forEach(trail => {
                totalParticles += trail.activeTrails.length;
            });
            totalParticles += activeRockets.length;

            // Estimate CPU load based on FPS degradation and particle count
            let cpuLoad = 0;
            if (fps > 0) {
                // CPU load increases as FPS drops below 60, and with particle count
                const fpsRatio = Math.max(0, (60 - fps) / 60);
                const particleLoad = Math.min(50, totalParticles / 100); // Max 50% from particles
                cpuLoad = Math.min(100, fpsRatio * 50 + particleLoad);
            }

            // Estimate GPU load based on particle density and rendering complexity
            let gpuLoad = 0;
            if (app.renderer.type === PIXI.RENDERER_TYPE.WEBGL) {
                // For WebGL, estimate based on particle count and screen fill
                const screenArea = app.screen.width * app.screen.height;
                const particleDensity = totalParticles / (screenArea / 1000000); // particles per megapixel
                const baseLoad = Math.min(30, totalParticles / 200); // Base load from particle count
                const densityLoad = Math.min(40, particleDensity * 20); // Additional load from density
                const fpsLoad = Math.max(0, (60 - fps) / 2); // FPS impact on GPU
                gpuLoad = Math.min(100, baseLoad + densityLoad + fpsLoad);
            } else {
                // Canvas renderer is more CPU intensive
                gpuLoad = Math.min(100, totalParticles / 50);
            }

            return {
                cpu: Math.round(cpuLoad),
                gpu: Math.round(gpuLoad)
            };
        }

        // Main loop
        app.ticker.add(() => {
            // FPS calculation
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fps = Math.round(frameCount * 1000 / (now - lastTime));
                fpsDisplay.textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastTime = now;
                
                // Update performance displays (once per second)
                const systemLoad = estimateSystemLoad();
                cpuLoadDisplay.textContent = `CPU: ${systemLoad.cpu}%`;
                gpuLoadDisplay.textContent = `GPU: ${systemLoad.gpu}%`;
            }

            // Update particle count display
            let totalParticles = 0;
            explosions.forEach(explosion => {
                totalParticles += explosion.particles.length;
                totalParticles += explosion.trails.length;
            });
            sparkleClouds.forEach(cloud => {
                totalParticles += cloud.sparkles.length;
            });
            activeRockets.forEach(rocket => {
                totalParticles += rocket.activeTrails.length;
            });
            fadingTrails.forEach(trail => {
                totalParticles += trail.activeTrails.length;
            });
            totalParticles += activeRockets.length; // Count the rockets themselves
            particleCountDisplay.textContent = `Particles: ${totalParticles}`;

            // Update timeline controller
            timelineController.update();
            
            // Update rockets
            for (let i = activeRockets.length - 1; i >= 0; i--) {
                if (!activeRockets[i].update()) {
                    fadingTrails.push(activeRockets[i]);
                    
                    // Prepare custom properties for explosion
                    const customProperties = {};
                    if (activeRockets[i].customParticleCount !== undefined) {
                        customProperties.particleCount = activeRockets[i].customParticleCount;
                    }
                    if (activeRockets[i].customParticleColor !== undefined) {
                        customProperties.particleColor = activeRockets[i].customParticleColor;
                    }
                    if (activeRockets[i].customTrailEnabled !== undefined) {
                        customProperties.trailEnabled = activeRockets[i].customTrailEnabled;
                    }
                    if (activeRockets[i].customSecondaryExplosion !== undefined) {
                        customProperties.secondaryExplosion = activeRockets[i].customSecondaryExplosion;
                    }
                    
                    explosions.push(new Explosion(
                        activeRockets[i].sprite.x,
                        activeRockets[i].sprite.y,
                        activeRockets[i].vx,
                        activeRockets[i].vy,
                        false,
                        null,
                        customProperties
                    ));
                    activeRockets.splice(i, 1);
                }
            }

            // Update fading trails
            for (let i = fadingTrails.length - 1; i >= 0; i--) {
                if (!fadingTrails[i].updateTrailsOnly()) {
                    fadingTrails.splice(i, 1);
                }
            }

            // Update explosions
            for (let i = explosions.length - 1; i >= 0; i--) {
                if (!explosions[i].update()) {
                    explosions.splice(i, 1);
                }
            }

            // Update sparkle clouds
            for (let i = sparkleClouds.length - 1; i >= 0; i--) {
                if (!sparkleClouds[i].update()) {
                    sparkleClouds.splice(i, 1);
                }
            }
        });

        // Auto-launch rockets when enabled (using dynamic interval)
        let lastAutoFireTime = Date.now();
        function checkAutoFire() {
            const currentTime = Date.now();
            const intervalMs = parseFloat(document.getElementById('autoFireIntervalSlider').value) * 1000;
            
            if (autoFireEnabled && (currentTime - lastAutoFireTime) >= intervalMs) {
                if (burstModeEnabled) {
                    // Fire multiple rockets in a burst
                    for (let i = 0; i < burstRocketCount; i++) {
                        launchRocket();
                    }
                } else {
                    // Fire single rocket
                    launchRocket();
                }
                lastAutoFireTime = currentTime;
            }
        }
        
        setInterval(checkAutoFire, 50); // Check frequently for responsive interval changes

        console.log('=== SETTING UP CLICK HANDLERS ===');
        
        // Click to create explosions or fire rockets
        app.stage.eventMode = 'static';
        app.stage.on('pointerdown', (e) => {
            console.log('Click detected! Auto fire enabled:', autoFireEnabled, 'Burst mode enabled:', burstModeEnabled);
            if (autoFireEnabled) {
                // When auto fire is enabled, clicking creates explosions
                console.log('Creating explosion at:', e.global.x, e.global.y);
                explosions.push(new Explosion(e.global.x, e.global.y));
            } else {
                // When auto fire is disabled, clicking fires rockets
                if (burstModeEnabled) {
                    // Fire multiple rockets in a burst
                    console.log('Launching burst of', burstRocketCount, 'rockets');
                    for (let i = 0; i < burstRocketCount; i++) {
                        launchRocket();
                    }
                } else {
                    // Fire single rocket
                    console.log('Launching single rocket');
                    launchRocket();
                }
            }
        });
        console.log('=== PIXI CLICK HANDLER SET UP ===');

        // Backup click handler on canvas element
        app.view.addEventListener('click', (e) => {
            console.log('Canvas click detected! Auto fire enabled:', autoFireEnabled, 'Burst mode enabled:', burstModeEnabled);
            const rect = app.view.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (autoFireEnabled) {
                console.log('Creating explosion at:', x, y);
                explosions.push(new Explosion(x, y));
            } else {
                // When auto fire is disabled, clicking fires rockets
                if (burstModeEnabled) {
                    // Fire multiple rockets in a burst
                    console.log('Launching burst of', burstRocketCount, 'rockets');
                    for (let i = 0; i < burstRocketCount; i++) {
                        launchRocket();
                    }
                } else {
                    // Fire single rocket
                    console.log('Launching single rocket');
                    launchRocket();
                }
            }
        });

        // Right-click handler for sparkle cloud
        app.view.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const rect = app.view.getBoundingClientRect();
            const centerX = e.clientX - rect.left;
            const centerY = e.clientY - rect.top;
            const radius = 120; // Max distance from center
            const numClouds = 32;
            for (let i = 0; i < numClouds; i++) {
                // Random angle and random radius (uniform distribution in circle)
                const angle = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()) * radius;
                const x = centerX + Math.cos(angle) * r;
                const y = centerY + Math.sin(angle) * r;
                sparkleClouds.push(new SparkleCloud(x, y));
            }
        });

        // Handle resize
        window.addEventListener('resize', () => {
            app.renderer.resize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>