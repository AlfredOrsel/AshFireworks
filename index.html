<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixiJS Fireworks - Version 10</title>
    <script src="https://pixijs.download/v7.3.2/pixi.min.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
        }
        canvas { display: block; }
        
        /* Ensure proper emoji rendering on all devices */
        .emoji-btn {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
            font-feature-settings: "liga", "kern", "calt";
            text-rendering: optimizeLegibility;
        }
    </style>
</head>
<body>
    <!-- UI Controls -->
    <div id="settingsPanel" style="position:fixed;top:10px;left:10px;z-index:1000;color:#fff;font-family:sans-serif;background:rgba(0,0,0,0.6);padding:8px 12px;border-radius:8px;transition:all 0.3s ease;">
        <div style="display:flex;justify-content:flex-start;align-items:center;margin-bottom:8px;gap:8px;">
            <button id="collapseBtn" style="padding: 6px 12px; border: none; background: #ff6b6b; color: white; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;" title="Collapse Settings">‚àí</button>
            <button id="doubleSizeBtn" class="emoji-btn" style="padding: 12px 24px; border: none; background: #2196F3; color: white; border-radius: 4px; cursor: pointer; font-size: 28px; font-weight: bold;" title="Double Size for Mobile">üîç</button>
        </div>
        <div id="settingsContent">
            <label>
                Particle count:
                <input type="range" id="particleCountSlider" min="50" max="200" value="120" style="vertical-align:middle;">
                <span id="particleCountValue">120</span>
            </label>
        <label style="margin-left:12px;">
            <input type="checkbox" id="randomParticleCount" style="vertical-align:middle;">
            Random
        </label>
        <br>
        <label>
            Min speed:
            <input type="range" id="minSpeedSlider" min="1" max="10" value="1" step="0.1" style="vertical-align:middle;width:80px;">
            <span id="minSpeedValue">1</span>
        </label>
        <label style="margin-left:12px;">
            Max speed:
            <input type="range" id="maxSpeedSlider" min="1" max="10" value="5" step="0.1" style="vertical-align:middle;width:80px;">
            <span id="maxSpeedValue">5</span>
        </label>
        <br>
        <label>
            <input type="checkbox" id="particleTrailCheckbox" checked>
            Particle trails
        </label>
        <label style="margin-left:12px;">
            <input type="checkbox" id="randomTrailCheckbox">
            Random
        </label>
        <br>
        <label>
            Particle lifetime:
            <input type="range" id="particleLifetimeSlider" min="20" max="80" value="50" style="vertical-align:middle;">
            <span id="particleLifetimeValue">50</span>
        </label>
        <label style="margin-left:12px;">
            <input type="checkbox" id="randomLifetimeCheckbox">
            Random
        </label>
        <br>
        <label>
            Particle gravity:
            <input type="range" id="particleGravitySlider" min="0" max="1" value="0.04" step="0.1" style="vertical-align:middle;width:80px;">
            <span id="particleGravityValue">0.04</span>
        </label>
        <br>
        <label>
            Rocket gravity:
            <input type="range" id="rocketGravitySlider" min="0" max="0.1" value="0.04" step="0.01" style="vertical-align:middle;width:80px;">
            <span id="rocketGravityValue">0.04</span>
        </label>
        <br>
        <label>
            Rocket speed:
            <input type="range" id="rocketSpeedSlider" min="4" max="10" value="7" step="0.1" style="vertical-align:middle;width:80px;">
            <span id="rocketSpeedValue">7</span>
        </label>
        <br>
        <label>
            <input type="checkbox" id="rocketMiniExplosionsCheckbox">
            Rocket mini explosions:
            <input type="range" id="rocketMiniExplosionIntervalSlider" min="0.2" max="1" value="0.5" step="0.1" style="vertical-align:middle;width:80px;">
            <span id="rocketMiniExplosionIntervalValue">0.5</span>s
        </label>
        <br>
        <label>
            Mini explosion particles:
            <input type="range" id="rocketMiniExplosionParticleCountSlider" min="10" max="50" value="15" style="vertical-align:middle;width:80px;">
            <span id="rocketMiniExplosionParticleCountValue">15</span>
        </label>
        <label style="margin-left:12px;">
            <input type="checkbox" id="rocketMiniExplosionSecondaryCheckbox">
            Secondary explosions
        </label>
        <br>
        <label>
            Explosion trigger (Bottom to top):
            <input type="range" id="explosionTriggerSlider" min="0" max="100" value="50" step="1" style="vertical-align:middle;width:80px;">
            <span id="explosionTriggerValue">50</span>
        </label>
        <label style="margin-left:12px;">
            <input type="checkbox" id="randomExplosionTriggerCheckbox">
            Random
        </label>
        <br>
        <label>
            <input type="checkbox" id="secondaryExplosionCheckbox" checked>
            Secondary explosion particles:
            <input type="range" id="secondaryParticleCountSlider" min="10" max="50" value="25" step="1" style="vertical-align:middle;width:80px;">
            <span id="secondaryParticleCountValue">25</span>
        </label>
        <label style="margin-left:12px;">
            <input type="checkbox" id="randomSecondaryTimingCheckbox">
            Random secondary explosion timing
        </label>
        <br>
        <label>Primary particle color:</label>
        <label style="margin-left:8px;">
            <input type="radio" name="primaryParticleColor" id="colorSilver" value="silver" checked> Silver
        </label>
        <label style="margin-left:8px;">
            <input type="radio" name="primaryParticleColor" id="colorGold" value="gold"> Gold
        </label>
        <label style="margin-left:8px;">
            <input type="radio" name="primaryParticleColor" id="colorRandom" value="random"> Random
        </label>
        <label style="margin-left:8px;">
            <input type="radio" name="primaryParticleColor" id="colorMulti" value="multi"> Multi
        </label>
        <br>
        <label>Payload types:</label>
        <br>
        <label style="margin-left:8px;">
            <input type="checkbox" name="payloadType" id="payloadRegular" value="regular" checked> Regular
        </label>
        <label style="margin-left:8px;">
            <input type="checkbox" name="payloadType" id="payloadSparkles" value="sparkles"> Sparkles
        </label>
        <label style="margin-left:8px;">
            <input type="checkbox" name="payloadType" id="payloadSpiral" value="spiral"> Spiral
        </label>
        <label style="margin-left:8px;">
            <input type="checkbox" name="payloadType" id="payloadSpiralCloud" value="spiralcloud"> Spiral Cloud
        </label>
        <label style="margin-left:8px;">
            <input type="checkbox" name="payloadType" id="payloadElliptical" value="elliptical"> Elliptical
        </label>
        <br>
        <label>
            <input type="checkbox" id="autoFireToggle"> Auto fire rockets
        </label>
        <label style="margin-left:12px;">
            <input type="checkbox" id="burstModeToggle"> Burst mode
        </label>
        <br>
        <label>
            Auto fire interval:
            <input type="range" id="autoFireIntervalSlider" min="0.2" max="2" value="0.6" step="0.1" style="vertical-align:middle;width:80px;">
            <span id="autoFireIntervalValue">0.6</span>s
        </label>
        <label style="margin-left:12px;">
            Burst rockets:
            <input type="range" id="burstRocketsSlider" min="2" max="10" value="3" step="1" style="vertical-align:middle;width:80px;" disabled>
            <span id="burstRocketsValue">3</span>
        </label>
        <br>
        <button id="startShowBtn" style="margin-top: 8px; padding: 6px 12px; border: none; background: #4CAF50; color: white; border-radius: 4px; cursor: pointer; font-size: 14px;">
            Start Show
        </button>
        </div>
    </div>

    <!-- Collapsed Settings Button -->
    <button id="expandBtn" style="position:fixed;top:18px;left:20px;z-index:1000;display:none;padding: 6px 12px; border: none; background: #4CAF50; color: white; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;transition:all 0.3s ease;" title="Expand Settings">+</button>

    <!-- Show JSON Dialog -->
    <div id="showDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2000; background: rgba(0,0,0,0.9); border: 2px solid #444; border-radius: 8px; padding: 20px; width: 600px; max-width: 90vw; max-height: 80vh; color: #fff; font-family: sans-serif;">
        <h3 style="margin-top: 0; color: #4CAF50;">Enter Fireworks Show JSON</h3>
        <textarea id="showJsonInput" style="width: 100%; height: 400px; background: #222; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 10px; font-family: monospace; font-size: 12px; resize: vertical; box-sizing: border-box;" placeholder="Enter your fireworks show JSON here...

Example:
{
  'name': 'My Show',
  'duration': 10,
  'events': [
    {
      'time': 0,
      'type': 'rockets',w
      'count': 5,
      'spread': 800,
      'particleColor': '0xC0C0C0',
      'trailEnabled': true,
      'secondaryExplosion': false
    }
  ]
}"></textarea>
        <div style="margin-top: 15px; text-align: right;">
            <button id="loadExampleBtn" style="margin-right: 10px; padding: 8px 16px; border: none; background: #2196F3; color: white; border-radius: 4px; cursor: pointer;">
                Load Example
            </button>
            <button id="cancelShowBtn" style="margin-right: 10px; padding: 8px 16px; border: none; background: #666; color: white; border-radius: 4px; cursor: pointer;">
                Cancel
            </button>
            <button id="executeShowBtn" style="padding: 8px 16px; border: none; background: #4CAF50; color: white; border-radius: 4px; cursor: pointer;">
                Start Show
            </button>
        </div>
    </div>

    <!-- Dialog Overlay -->
    <div id="dialogOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1999;"></div>
    <script>
        console.log('=== FIREWORKS SCRIPT STARTING ===');
        
        // ================================================
        // FIREWORKS SIMULATION - VERSION 10
        // ================================================

        // User controls
        let particleCount = 120;
        let randomParticleCount = false;
        let minExplosionSpeed = 1;
        let maxExplosionSpeed = 5;
        let particleTrailsEnabled = true;
        let randomParticleTrails = false;
        let particleLifetime = 50;
        let randomParticleLifetime = false;
        let particleGravity = 0.04;
        let rocketGravity = 0.04;
        let rocketSpeed = 7;
        let explosionTriggerPercent = 50;
        let randomExplosionTrigger = false;
        let secondaryParticleCount = 25;
        let secondaryExplosionsEnabled = true;
        let randomSecondaryTiming = false;
        let primaryParticleColorMode = "silver";
        let autoFireEnabled = false;
        let burstModeEnabled = false;
        let burstRocketCount = 3;
        let rocketMiniExplosionsEnabled = false;
        let rocketMiniExplosionInterval = 0.5;
        let rocketMiniExplosionParticleCount = 15;
        let rocketMiniExplosionSecondaryEnabled = false;

        // Payload system variables
        let payloadRegularEnabled = true;
        let payloadSparklesEnabled = false;
        let payloadSpiralEnabled = false;
        let payloadSpiralCloudEnabled = false;
        let payloadEllipticalEnabled = false;


        const slider = document.getElementById('particleCountSlider');
        const sliderValue = document.getElementById('particleCountValue');
        const randomCheckbox = document.getElementById('randomParticleCount');
        const minSpeedSlider = document.getElementById('minSpeedSlider');
        const maxSpeedSlider = document.getElementById('maxSpeedSlider');
        const minSpeedValue = document.getElementById('minSpeedValue');
        const maxSpeedValue = document.getElementById('maxSpeedValue');
        const particleTrailCheckbox = document.getElementById('particleTrailCheckbox');
        const randomTrailCheckbox = document.getElementById('randomTrailCheckbox');
        const particleLifetimeSlider = document.getElementById('particleLifetimeSlider');
        const particleLifetimeValue = document.getElementById('particleLifetimeValue');
        const randomLifetimeCheckbox = document.getElementById('randomLifetimeCheckbox');
        const particleGravitySlider = document.getElementById('particleGravitySlider');
        const particleGravityValue = document.getElementById('particleGravityValue');
        const rocketGravitySlider = document.getElementById('rocketGravitySlider');
        const rocketGravityValue = document.getElementById('rocketGravityValue');
        const rocketSpeedSlider = document.getElementById('rocketSpeedSlider');
        const rocketSpeedValue = document.getElementById('rocketSpeedValue');
        const explosionTriggerSlider = document.getElementById('explosionTriggerSlider');
        const explosionTriggerValue = document.getElementById('explosionTriggerValue');
        const randomExplosionTriggerCheckbox = document.getElementById('randomExplosionTriggerCheckbox');
        const secondaryParticleCountSlider = document.getElementById('secondaryParticleCountSlider');
        const secondaryParticleCountValue = document.getElementById('secondaryParticleCountValue');
        const secondaryExplosionCheckbox = document.getElementById('secondaryExplosionCheckbox');
        const randomSecondaryTimingCheckbox = document.getElementById('randomSecondaryTimingCheckbox');
        const rocketMiniExplosionsCheckbox = document.getElementById('rocketMiniExplosionsCheckbox');
        const rocketMiniExplosionIntervalSlider = document.getElementById('rocketMiniExplosionIntervalSlider');
        const rocketMiniExplosionIntervalValue = document.getElementById('rocketMiniExplosionIntervalValue');
        const rocketMiniExplosionParticleCountSlider = document.getElementById('rocketMiniExplosionParticleCountSlider');
        const rocketMiniExplosionParticleCountValue = document.getElementById('rocketMiniExplosionParticleCountValue');
        const rocketMiniExplosionSecondaryCheckbox = document.getElementById('rocketMiniExplosionSecondaryCheckbox');

        // Payload system elements
        const payloadRegularCheckbox = document.getElementById('payloadRegular');
        const payloadSparklesCheckbox = document.getElementById('payloadSparkles');
        const payloadSpiralCheckbox = document.getElementById('payloadSpiral');
        const payloadSpiralCloudCheckbox = document.getElementById('payloadSpiralCloud');
        const payloadEllipticalCheckbox = document.getElementById('payloadElliptical');

        // Primary particle color radio buttons
        document.getElementById('colorSilver').addEventListener('change', (event) => { if (event.target.checked) primaryParticleColorMode = "silver"; });
        document.getElementById('colorGold').addEventListener('change', (event) => { if (event.target.checked) primaryParticleColorMode = "gold"; });
        document.getElementById('colorRandom').addEventListener('change', (event) => { if (event.target.checked) primaryParticleColorMode = "random"; });
        document.getElementById('colorMulti').addEventListener('change', (event) => { if (event.target.checked) primaryParticleColorMode = "multi"; });



        function getPrimaryParticleColor() {
            switch (primaryParticleColorMode) {
                case "silver": return 0xC0C0C0;
                case "gold": return 0xFFD700;
                case "random": return Math.floor(Math.random() * 0xFFFFFF);
                // Remove "multi" from here!
                default: return 0xC0C0C0;
            }
        }

        // Function to randomly select a payload type from enabled options
        function getRandomPayloadType() {
            const enabledPayloads = [];
            
            if (payloadRegularEnabled) enabledPayloads.push('regular');
            if (payloadSparklesEnabled) enabledPayloads.push('sparkles');
            if (payloadSpiralEnabled) enabledPayloads.push('spiral');
            if (payloadSpiralCloudEnabled) enabledPayloads.push('spiralcloud');
            if (payloadEllipticalEnabled) enabledPayloads.push('elliptical');
            
            // If no payloads are enabled, default to regular
            if (enabledPayloads.length === 0) {
                return 'regular';
            }
            
            // Randomly select one of the enabled payload types
            const randomIndex = Math.floor(Math.random() * enabledPayloads.length);
            return enabledPayloads[randomIndex];
        }

        // Function to create explosion based on payload type
        function createExplosionByPayload(x, y, inheritVx = 0, inheritVy = 0, customProperties = {}) {
            const payloadType = getRandomPayloadType();
            
            switch (payloadType) {
                case 'regular':
                    explosions.push(new Explosion(x, y, inheritVx, inheritVy, false, null, customProperties));
                    break;
                case 'sparkles':
                    const sparkleCount = customProperties.particleCount || 120;
                    sparkleClouds.push(new SparkleCloud(x, y, sparkleCount));
                    break;
                case 'spiral':
                    activeSpiralExplosions.push(new SpiralExplosion(x, y));
                    break;
                case 'spiralcloud':
                    // Create multiple spiral explosions in a cloud pattern
                    const cloudRadius = 100;
                    const spiralCount = 16;
                    for (let i = 0; i < spiralCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * cloudRadius;
                        const spiralX = x + Math.cos(angle) * distance;
                        const spiralY = y + Math.sin(angle) * distance;
                        activeSpiralExplosions.push(new SpiralExplosion(spiralX, spiralY));
                    }
                    break;
                case 'elliptical':
                    const colors = [0xC0C0C0, 0xFFD700]; // Silver and Gold
                    const color = customProperties.particleColor || colors[Math.floor(Math.random() * colors.length)];
                    activeEllipticalExplosions.push(new EllipticalExplosion(x, y, color));
                    break;
                default:
                    explosions.push(new Explosion(x, y, inheritVx, inheritVy, false, null, customProperties));
                    break;
            }
        }

        slider.addEventListener('input', () => {
            particleCount = parseInt(slider.value, 10);
            sliderValue.textContent = particleCount;
        });
        randomCheckbox.addEventListener('change', () => {
            randomParticleCount = randomCheckbox.checked;
        });
        minSpeedSlider.addEventListener('input', () => {
            minExplosionSpeed = parseFloat(minSpeedSlider.value);
            minSpeedValue.textContent = minExplosionSpeed;
            if (minExplosionSpeed > maxExplosionSpeed) {
                maxExplosionSpeed = minExplosionSpeed;
                maxSpeedSlider.value = minExplosionSpeed;
                maxSpeedValue.textContent = minExplosionSpeed;
            }
        });
        maxSpeedSlider.addEventListener('input', () => {
            maxExplosionSpeed = parseFloat(maxSpeedSlider.value);
            maxSpeedValue.textContent = maxExplosionSpeed;
            if (maxExplosionSpeed < minExplosionSpeed) {
                minExplosionSpeed = maxExplosionSpeed;
                minSpeedSlider.value = maxExplosionSpeed;
                minSpeedValue.textContent = maxExplosionSpeed;
            }
        });
        particleTrailCheckbox.addEventListener('change', () => {
            particleTrailsEnabled = particleTrailCheckbox.checked;
        });
        randomTrailCheckbox.addEventListener('change', () => {
            randomParticleTrails = randomTrailCheckbox.checked;
        });
        particleLifetimeSlider.addEventListener('input', () => {
            particleLifetime = parseInt(particleLifetimeSlider.value, 10);
            particleLifetimeValue.textContent = particleLifetime;
        });
        randomLifetimeCheckbox.addEventListener('change', () => {
            randomParticleLifetime = randomLifetimeCheckbox.checked;
        });
        particleGravitySlider.addEventListener('input', () => {
            particleGravity = parseFloat(particleGravitySlider.value);
            particleGravityValue.textContent = particleGravity;
        });
        rocketGravitySlider.addEventListener('input', () => {
            rocketGravity = parseFloat(rocketGravitySlider.value);
            rocketGravityValue.textContent = rocketGravity.toFixed(2);
        });
        rocketSpeedSlider.addEventListener('input', () => {
            rocketSpeed = parseFloat(rocketSpeedSlider.value);
            rocketSpeedValue.textContent = rocketSpeed;
        });
        explosionTriggerSlider.addEventListener('input', () => {
            explosionTriggerPercent = parseInt(explosionTriggerSlider.value, 10);
            explosionTriggerValue.textContent = explosionTriggerPercent;
        });
        randomExplosionTriggerCheckbox.addEventListener('change', () => {
            randomExplosionTrigger = randomExplosionTriggerCheckbox.checked;
        });
        secondaryParticleCountSlider.addEventListener('input', () => {
            secondaryParticleCount = parseInt(secondaryParticleCountSlider.value, 10);
            secondaryParticleCountValue.textContent = secondaryParticleCount;
        });
        secondaryExplosionCheckbox.addEventListener('change', () => {
            secondaryExplosionsEnabled = secondaryExplosionCheckbox.checked;
        });
        randomSecondaryTimingCheckbox.addEventListener('change', () => {
            randomSecondaryTiming = randomSecondaryTimingCheckbox.checked;
        });
        rocketMiniExplosionsCheckbox.addEventListener('change', () => {
            rocketMiniExplosionsEnabled = rocketMiniExplosionsCheckbox.checked;
        });
        rocketMiniExplosionIntervalSlider.addEventListener('input', () => {
            rocketMiniExplosionInterval = parseFloat(rocketMiniExplosionIntervalSlider.value);
            rocketMiniExplosionIntervalValue.textContent = rocketMiniExplosionInterval;
        });
        rocketMiniExplosionParticleCountSlider.addEventListener('input', () => {
            rocketMiniExplosionParticleCount = parseInt(rocketMiniExplosionParticleCountSlider.value, 10);
            rocketMiniExplosionParticleCountValue.textContent = rocketMiniExplosionParticleCount;
        });
        rocketMiniExplosionSecondaryCheckbox.addEventListener('change', () => {
            rocketMiniExplosionSecondaryEnabled = rocketMiniExplosionSecondaryCheckbox.checked;
        });

        // Payload system event listeners
        payloadRegularCheckbox.addEventListener('change', () => {
            payloadRegularEnabled = payloadRegularCheckbox.checked;
        });
        payloadSparklesCheckbox.addEventListener('change', () => {
            payloadSparklesEnabled = payloadSparklesCheckbox.checked;
        });
        payloadSpiralCheckbox.addEventListener('change', () => {
            payloadSpiralEnabled = payloadSpiralCheckbox.checked;
        });
        payloadSpiralCloudCheckbox.addEventListener('change', () => {
            payloadSpiralCloudEnabled = payloadSpiralCloudCheckbox.checked;
        });
        payloadEllipticalCheckbox.addEventListener('change', () => {
            payloadEllipticalEnabled = payloadEllipticalCheckbox.checked;
        });

        // Auto fire toggle
        const autoFireToggle = document.getElementById('autoFireToggle');
        autoFireToggle.addEventListener('change', () => {
            autoFireEnabled = autoFireToggle.checked;
        });

        // Burst mode toggle
        const burstModeToggle = document.getElementById('burstModeToggle');
        burstModeToggle.addEventListener('change', () => {
            burstModeEnabled = burstModeToggle.checked;
            
            // Enable/disable burst rockets slider based on burst mode state
            const burstRocketsSlider = document.getElementById('burstRocketsSlider');
            burstRocketsSlider.disabled = !burstModeEnabled;
        });

        // Burst rockets slider
        const burstRocketsSlider = document.getElementById('burstRocketsSlider');
        const burstRocketsValue = document.getElementById('burstRocketsValue');
        burstRocketsSlider.addEventListener('input', () => {
            burstRocketCount = parseInt(burstRocketsSlider.value, 10);
            burstRocketsValue.textContent = burstRocketCount;
        });

        // Auto fire interval slider
        const autoFireIntervalSlider = document.getElementById('autoFireIntervalSlider');
        const autoFireIntervalValue = document.getElementById('autoFireIntervalValue');
        autoFireIntervalSlider.addEventListener('input', () => {
            autoFireIntervalValue.textContent = autoFireIntervalSlider.value;
        });

        // Show dialog elements
        const startShowBtn = document.getElementById('startShowBtn');
        const showDialog = document.getElementById('showDialog');
        const dialogOverlay = document.getElementById('dialogOverlay');
        const showJsonInput = document.getElementById('showJsonInput');
        const cancelShowBtn = document.getElementById('cancelShowBtn');
        const executeShowBtn = document.getElementById('executeShowBtn');
        const loadExampleBtn = document.getElementById('loadExampleBtn');

        // Load example JSON
        const exampleJSON = {
            "name": "Simple Test Show",
            "duration": 8000,
            "events": [
                {
                    "time": 0,
                    "type": "rockets",
                    "count": 3,
                    "spread": 600,
                    "particleColor": "0xC0C0C0",
                    "trailEnabled": true,
                    "secondaryExplosion": false
                },
                {
                    "time": 2000,
                    "type": "rockets",
                    "count": 5,
                    "spread": 800,
                    "particleColor": "0xFFD700",
                    "trailEnabled": true,
                    "secondaryExplosion": true
                },
                {
                    "time": 4000,
                    "type": "sparkles",
                    "x": 400,
                    "y": 200,
                    "count": 80
                }
            ]
        };

        // Show dialog functionality
        function openShowDialog() {
            showDialog.style.display = 'block';
            dialogOverlay.style.display = 'block';
            showJsonInput.focus();
        }

        function closeShowDialog() {
            showDialog.style.display = 'none';
            dialogOverlay.style.display = 'none';
        }

        // Event listeners for dialog
        startShowBtn.addEventListener('click', openShowDialog);
        cancelShowBtn.addEventListener('click', closeShowDialog);
        dialogOverlay.addEventListener('click', closeShowDialog);
        
        // Load example button
        loadExampleBtn.addEventListener('click', () => {
            showJsonInput.value = JSON.stringify(exampleJSON, null, 2);
        });

        // Execute show button (now with controller logic)
        executeShowBtn.addEventListener('click', () => {
            const jsonText = showJsonInput.value.trim();
            if (jsonText) {
                try {
                    console.log('Raw JSON text:', jsonText);
                    const showData = JSON.parse(jsonText);
                    console.log('Parsed show data:', showData);
                    console.log('Show data type:', typeof showData);
                    console.log('Events property:', showData.events);
                    console.log('Events is array:', Array.isArray(showData.events));
                    
                    // Validate basic structure
                    if (!showData.events) {
                        throw new Error('Show data must have an "events" property');
                    }
                    if (!Array.isArray(showData.events)) {
                        throw new Error('Show data "events" must be an array');
                    }
                    if (showData.events.length === 0) {
                        throw new Error('Show data "events" array cannot be empty');
                    }
                    
                    // Start the timeline controller
                    timelineController.startShow(showData);
                    closeShowDialog();
                } catch (error) {
                    alert('Invalid JSON format or structure. Please check your input.\n\nError: ' + error.message);
                    console.error('JSON parsing error:', error);
                    console.error('Raw input was:', jsonText);
                }
            } else {
                alert('Please enter show JSON data.');
            }
        });

        // Close dialog with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && showDialog.style.display === 'block') {
                closeShowDialog();
            }
            
            // Elliptical explosion on 'K' key
            if (e.key === 'K' || e.key === 'k') {
                createEllipticalExplosion();
            }
            
            // Spiral explosion on 'L' key
            if (e.key === 'L' || e.key === 'l') {
                createSpiralExplosion();
            }
            
            // Spiral cloud on 'N' key
            if (e.key === 'N' || e.key === 'n') {
                createSpiralCloud();
            }
        });

        // Settings panel collapse/expand functionality
        const settingsPanel = document.getElementById('settingsPanel');
        const settingsContent = document.getElementById('settingsContent');
        const collapseBtn = document.getElementById('collapseBtn');
        const expandBtn = document.getElementById('expandBtn');

        function collapseSettings() {
            settingsContent.style.display = 'none';
            settingsPanel.style.display = 'none';
            expandBtn.style.display = 'block';
            doubleSizeBtn.style.display = 'none'; // Hide zoom button when collapsed
            
            // Apply current zoom level to expand button
            applyExpandButtonZoom(zoomLevel);
        }

        function expandSettings() {
            settingsContent.style.display = 'block';
            settingsPanel.style.display = 'block';
            expandBtn.style.display = 'none';
            doubleSizeBtn.style.display = 'inline-block'; // Show zoom button when expanded
            
            // Reapply current zoom level to maintain state
            applyZoom(zoomLevel);
        }
        
        function applyExpandButtonZoom(level) {
            if (level === 1) {
                expandBtn.style.fontSize = '14px';
                expandBtn.style.padding = '6px 12px';
            } else if (level === 2) {
                expandBtn.style.fontSize = '18px';
                expandBtn.style.padding = '12px 24px';
            } else if (level === 3) {
                expandBtn.style.fontSize = '24px';
                expandBtn.style.padding = '18px 36px';
            }
        }

        collapseBtn.addEventListener('click', collapseSettings);
        expandBtn.addEventListener('click', expandSettings);

        // Add hover effects via JavaScript
        collapseBtn.addEventListener('mouseenter', () => {
            collapseBtn.style.background = '#ff5252';
        });
        collapseBtn.addEventListener('mouseleave', () => {
            collapseBtn.style.background = '#ff6b6b';
        });

        expandBtn.addEventListener('mouseenter', () => {
            expandBtn.style.background = '#45a049';
        });
        expandBtn.addEventListener('mouseleave', () => {
            expandBtn.style.background = '#4CAF50';
        });

        // Multi-level zoom functionality for mobile
        let zoomLevel = 1; // 1 = normal, 2 = double, 3 = triple
        const doubleSizeBtn = document.getElementById('doubleSizeBtn');
        
        function toggleZoomLevel() {
            zoomLevel++;
            if (zoomLevel > 3) {
                zoomLevel = 1; // Reset to normal after triple
            }
            
            const settingsContent = document.getElementById('settingsContent');
            const collapseBtn = document.getElementById('collapseBtn');
            
            // Apply zoom based on current level
            applyZoom(zoomLevel);
        }
        
        function applyZoom(level) {
            const settingsContent = document.getElementById('settingsContent');
            const collapseBtn = document.getElementById('collapseBtn');
            
            if (level === 1) {
                // Normal size
                settingsContent.style.fontSize = '';
                settingsContent.style.lineHeight = '';
                
                // Reset input elements
                const inputs = settingsContent.querySelectorAll('input[type="range"], input[type="checkbox"], input[type="radio"]');
                inputs.forEach(input => {
                    if (input.type === 'range') {
                        input.style.width = input.getAttribute('data-original-width') || '80px';
                        input.style.height = '';
                    } else {
                        input.style.transform = '';
                        input.style.margin = '';
                    }
                });
                
                // Reset buttons
                const buttons = settingsContent.querySelectorAll('button');
                buttons.forEach(button => {
                    button.style.fontSize = '14px';
                    button.style.padding = '6px 12px';
                });
                
                // Reset the collapse button and zoom button
                collapseBtn.style.fontSize = '14px';
                collapseBtn.style.padding = '6px 12px';
                doubleSizeBtn.style.fontSize = '28px';
                doubleSizeBtn.style.padding = '12px 24px';
                
                // Reset the expand button
                expandBtn.style.fontSize = '14px';
                expandBtn.style.padding = '6px 12px';
                
                // Update button text
                doubleSizeBtn.innerHTML = 'üîç';
                doubleSizeBtn.title = 'Double Size for Mobile';
                
                // Reset panel padding
                settingsPanel.style.padding = '8px 12px';
                
            } else if (level === 2) {
                // Double size
                settingsContent.style.fontSize = '18px';
                settingsContent.style.lineHeight = '2.2';
                
                // Scale up input elements
                const inputs = settingsContent.querySelectorAll('input[type="range"], input[type="checkbox"], input[type="radio"]');
                inputs.forEach(input => {
                    if (input.type === 'range') {
                        input.style.width = input.style.width ? (parseInt(input.getAttribute('data-original-width') || '80') * 2) + 'px' : '160px';
                        input.style.height = '24px';
                    } else {
                        input.style.transform = 'scale(1.8)';
                        input.style.margin = '8px';
                    }
                });
                
                // Scale up buttons
                const buttons = settingsContent.querySelectorAll('button');
                buttons.forEach(button => {
                    button.style.fontSize = '18px';
                    button.style.padding = '12px 24px';
                });
                
                // Scale up the collapse button and zoom button
                collapseBtn.style.fontSize = '18px';
                collapseBtn.style.padding = '12px 24px';
                doubleSizeBtn.style.fontSize = '36px';
                doubleSizeBtn.style.padding = '24px 48px';
                
                // Scale up the expand button
                expandBtn.style.fontSize = '18px';
                expandBtn.style.padding = '12px 24px';
                
                // Update button text
                doubleSizeBtn.innerHTML = 'üîç+';
                doubleSizeBtn.title = 'Triple Size for Mobile';
                
                // Increase panel padding
                settingsPanel.style.padding = '16px 24px';
                
            } else if (level === 3) {
                // Triple size
                settingsContent.style.fontSize = '24px';
                settingsContent.style.lineHeight = '2.8';
                
                // Scale up input elements even more
                const inputs = settingsContent.querySelectorAll('input[type="range"], input[type="checkbox"], input[type="radio"]');
                inputs.forEach(input => {
                    if (input.type === 'range') {
                        input.style.width = input.style.width ? (parseInt(input.getAttribute('data-original-width') || '80') * 3) + 'px' : '240px';
                        input.style.height = '32px';
                    } else {
                        input.style.transform = 'scale(2.5)';
                        input.style.margin = '12px';
                    }
                });
                
                // Scale up buttons to triple size
                const buttons = settingsContent.querySelectorAll('button');
                buttons.forEach(button => {
                    button.style.fontSize = '24px';
                    button.style.padding = '18px 36px';
                });
                
                // Scale up the collapse button and zoom button
                collapseBtn.style.fontSize = '24px';
                collapseBtn.style.padding = '18px 36px';
                doubleSizeBtn.style.fontSize = '48px';
                doubleSizeBtn.style.padding = '36px 72px';
                
                // Scale up the expand button
                expandBtn.style.fontSize = '24px';
                expandBtn.style.padding = '18px 36px';
                
                // Update button text
                doubleSizeBtn.innerHTML = 'üîç‚àí';
                doubleSizeBtn.title = 'Normal Size';
                
                // Increase panel padding even more
                settingsPanel.style.padding = '24px 36px';
            }
        }
        
        doubleSizeBtn.addEventListener('click', toggleZoomLevel);
        
        // Add hover effects for double size button
        doubleSizeBtn.addEventListener('mouseenter', () => {
            doubleSizeBtn.style.background = '#1976D2';
        });
        doubleSizeBtn.addEventListener('mouseleave', () => {
            doubleSizeBtn.style.background = '#2196F3';
        });

        // Store original widths for range inputs
        document.addEventListener('DOMContentLoaded', () => {
            const rangeInputs = document.querySelectorAll('input[type="range"]');
            rangeInputs.forEach(input => {
                input.setAttribute('data-original-width', input.style.width || '80px');
            });
        });

        // Initialize PixiJS
        console.log('=== INITIALIZING PIXIJS ===');
        const app = new PIXI.Application({
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundColor: 0x000000,
            antialias: true
        });
        console.log('=== PIXIJS APP CREATED ===');
        document.body.appendChild(app.view);
        console.log('=== PIXIJS CANVAS ADDED TO BODY ===');

        // FPS Counter
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;

        // Performance monitoring variables
        let baselineParticles = 0;
        let baselineFPS = 60;
        let performanceSamples = [];
        let lastUpdateTime = performance.now();

        // Create FPS display element
        const fpsDisplay = document.createElement('div');
        fpsDisplay.style.cssText = 'position:fixed;top:10px;right:10px;color:#0f0;font-family:monospace;background:rgba(0,0,0,0.7);padding:5px 8px;border-radius:4px;z-index:1001;font-size:14px;font-weight:bold;';
        fpsDisplay.textContent = 'FPS: --';
        document.body.appendChild(fpsDisplay);

        // Create particle count display element
        const particleCountDisplay = document.createElement('div');
        particleCountDisplay.style.cssText = 'position:fixed;top:40px;right:10px;color:#ff0;font-family:monospace;background:rgba(0,0,0,0.7);padding:5px 8px;border-radius:4px;z-index:1001;font-size:14px;font-weight:bold;';
        particleCountDisplay.textContent = 'Particles: 0';
        document.body.appendChild(particleCountDisplay);

        // Create CPU load display element
        const cpuLoadDisplay = document.createElement('div');
        cpuLoadDisplay.style.cssText = 'position:fixed;top:70px;right:10px;color:#0ff;font-family:monospace;background:rgba(0,0,0,0.7);padding:5px 8px;border-radius:4px;z-index:1001;font-size:14px;font-weight:bold;';
        cpuLoadDisplay.textContent = 'CPU: --';
        document.body.appendChild(cpuLoadDisplay);

        // Create GPU load display element
        const gpuLoadDisplay = document.createElement('div');
        gpuLoadDisplay.style.cssText = 'position:fixed;top:100px;right:10px;color:#f0f;font-family:monospace;background:rgba(0,0,0,0.7);padding:5px 8px;border-radius:4px;z-index:1001;font-size:14px;font-weight:bold;';
        gpuLoadDisplay.textContent = 'GPU: --';
        document.body.appendChild(gpuLoadDisplay);

        // Texture creation
        function createCircleTexture(radius, color) {
            const graphic = new PIXI.Graphics();
            graphic.beginFill(color);
            graphic.drawCircle(radius, radius, radius);
            graphic.endFill();
            return app.renderer.generateTexture(graphic);
        }

        // Textures
        const rocketTexture = createCircleTexture(4, 0xFFFFFF);
        const rocketTrailTexture = createCircleTexture(3, 0xFFFFFF);
        const explosionParticleTexture = createCircleTexture(5, 0xFFFFFF);
        const explosionTrailTexture = createCircleTexture(3, 0x888888);

        // Containers - Unlimited for performance testing
        const rocketContainer = new PIXI.Container();
        const explosionContainer = new PIXI.Container();
        app.stage.addChild(rocketContainer);
        app.stage.addChild(explosionContainer);

        // Rocket Trail Class (Version 4 modification)
        class RocketTrail {
            constructor(x, y) {
                this.sprite = new PIXI.Sprite(rocketTrailTexture);
                this.sprite.anchor.set(0.5);
                this.sprite.x = x;
                this.sprite.y = y;
                this.initialSize = 1.5;
                this.sprite.scale.set(this.initialSize);
                this.life = 25;
                this.currentLife = this.life;
                this.sprite.alpha = 0.7;
                rocketContainer.addChild(this.sprite);
            }

            update() {
                this.currentLife--;
                const progress = this.currentLife / this.life;
                this.sprite.scale.set(this.initialSize * progress);
                this.sprite.alpha = progress * 0.7;
                if (this.currentLife <= 0) {
                    rocketContainer.removeChild(this.sprite);
                    return false;
                }
                return true;
            }
        }

        // Rocket Class
        class Rocket {
            constructor(x, targetY) {
                this.sprite = new PIXI.Sprite(rocketTexture);
                this.sprite.anchor.set(0.5);
                this.sprite.x = x;
                this.sprite.y = app.screen.height;
                this.targetY = targetY;
                this.activeTrails = [];
                this.vx = (Math.random() - 0.5) * 2; // random deviation: -1 to +1 px per frame
                
                // Use custom rocket speed if set, otherwise use global setting
                const currentSpeed = this.customRocketSpeed || rocketSpeed;
                this.vy = -currentSpeed; // use configurable upward velocity
                this.initialVy = this.vy; // <-- store initial speed
                
                // Set per-rocket explosion trigger percent
                if (randomExplosionTrigger) {
                    this.explosionTriggerPercent = Math.floor(Math.random() * 101); // 0-100
                } else {
                    this.explosionTriggerPercent = explosionTriggerPercent;
                }
                
                // Mini explosion timing
                this.lastMiniExplosionTime = 0;
                this.frameCount = 0;
                
                rocketContainer.addChild(this.sprite);
            }

            addTrail() {
                this.activeTrails.push(new RocketTrail(this.sprite.x, this.sprite.y));
            }

            update() {
                this.sprite.x += this.vx;
                this.sprite.y += this.vy;
                this.vy += rocketGravity;
                this.addTrail();
                this.frameCount++;

                // Check for mini explosions
                if (rocketMiniExplosionsEnabled) {
                    const intervalFrames = rocketMiniExplosionInterval * 60; // Convert seconds to frames (assuming 60 FPS)
                    if (this.frameCount - this.lastMiniExplosionTime >= intervalFrames) {
                        // Create mini explosion at current rocket position
                        explosions.push(new Explosion(
                            this.sprite.x, 
                            this.sprite.y, 
                            this.vx * 0.3, // inherit rocket's horizontal velocity (reduced)
                            this.vy * 0.3, // inherit rocket's vertical velocity (reduced)
                            false, // not a secondary explosion
                            null, // use default color logic
                            { 
                                particleCount: rocketMiniExplosionParticleCount, 
                                maxSpeed: 2,
                                secondaryExplosion: rocketMiniExplosionSecondaryEnabled
                            } // configurable mini explosion with optional secondary explosions
                        ));
                        this.lastMiniExplosionTime = this.frameCount;
                    }
                }

                for (let i = this.activeTrails.length - 1; i >= 0; i--) {
                    if (!this.activeTrails[i].update()) {
                        rocketContainer.removeChild(this.activeTrails[i].sprite);
                        this.activeTrails.splice(i, 1);
                    }
                }

                // Configurable explosion trigger based on percentage of initial speed
                // 100% = explode immediately, 0% = explode at the top (vy crosses 0)
                let triggerVy = this.initialVy * (1 - this.explosionTriggerPercent / 100);
                if (this.vy > triggerVy) {
                    // Create explosion using payload system
                    createExplosionByPayload(this.sprite.x, this.sprite.y, this.vx, this.vy);
                    
                    rocketContainer.removeChild(this.sprite);
                    return false;
                }
                return true;
            }

            updateTrailsOnly() {
                for (let i = this.activeTrails.length - 1; i >= 0; i--) {
                    if (!this.activeTrails[i].update()) {
                        rocketContainer.removeChild(this.activeTrails[i].sprite);
                        this.activeTrails.splice(i, 1);
                    }
                }
                return this.activeTrails.length > 0;
            }
        }

        // Explosion System
        class Explosion {
            constructor(x, y, inheritVx = 0, inheritVy = 0, isSecondary = false, color = null, customProperties = {}) {
                this.particles = [];
                this.trails = [];
                
                // Use custom color if provided, otherwise use default logic
                this.color = color !== null ? color :
                    (customProperties.particleColor !== undefined ? customProperties.particleColor :
                        (!isSecondary ? getPrimaryParticleColor() : Math.random() * 0xFFFFFF));
                
                this.x = x;
                this.y = y;
                this.inheritVx = inheritVx;
                this.inheritVy = inheritVy;
                this.isSecondary = isSecondary;
                
                // Use custom trail setting if provided
                this.trailsEnabled = customProperties.trailEnabled !== undefined ? 
                    customProperties.trailEnabled : 
                    (!isSecondary && particleTrailsEnabled);
                
                if (!isSecondary && randomParticleTrails && customProperties.trailEnabled === undefined) {
                    this.trailsEnabled = Math.random() < 0.5;
                }
                
                this.thisLifetime = particleLifetime;
                if (!isSecondary && randomParticleLifetime) {
                    this.thisLifetime = Math.random() * (particleLifetimeSlider.max - particleLifetimeSlider.min) + parseInt(particleLifetimeSlider.min, 10);
                }
                if (isSecondary) {
                    this.thisLifetime = 40;
                }
                
                // Store custom properties
                this.customParticleCount = customProperties.particleCount;
                this.customSecondaryExplosion = customProperties.secondaryExplosion;
                this.customMaxSpeed = customProperties.maxSpeed;
                
                this.initParticles();
            }

            initParticles() {
                let count = this.customParticleCount !== undefined ? 
                    this.customParticleCount : 
                    (this.isSecondary ? secondaryParticleCount : particleCount);
                
                if (!this.isSecondary && randomParticleCount && this.customParticleCount === undefined) {
                    count = Math.floor(Math.random() * (slider.max - slider.min + 1)) + parseInt(slider.min, 10);
                }
                
                for (let i = 0; i < count; i++) {
                    const p = new PIXI.Sprite(explosionParticleTexture);
                    // Assign random color per particle for multi mode, otherwise use this.color
                    if (!this.isSecondary && primaryParticleColorMode === "multi") {
                        p.tint = Math.floor(Math.random() * 0xFFFFFF);
                    } else {
                        p.tint = this.color;
                    }
                    p.anchor.set(0.5);
                    p.x = this.x;
                    p.y = this.y;
                    const angle = Math.random() * Math.PI * 2;
                    
                    let speed;
                    if (this.customMaxSpeed !== undefined) {
                        // Use custom max speed for mini explosions
                        speed = Math.random() * this.customMaxSpeed;
                    } else {
                        // Use default speed calculation
                        speed = Math.random() * (maxExplosionSpeed - minExplosionSpeed) + minExplosionSpeed;
                        if (this.isSecondary) {
                            speed *= 0.5;
                        }
                    }
                    
                    p.vx = Math.cos(angle) * speed + this.inheritVx * 0.5;
                    p.vy = Math.sin(angle) * speed + this.inheritVy * 0.5;
                    p.scale.set(this.isSecondary ? 0.3 : 0.5);
                    p.life = this.thisLifetime;
                    p.maxLife = this.thisLifetime;
                    p.hasSpawnedSecondary = false;
                    explosionContainer.addChild(p);
                    this.particles.push(p);
                }
            }

            addParticleTrail(particle) {
                if (!this.trailsEnabled) return;
                const trail = new PIXI.Sprite(explosionTrailTexture);
                trail.tint = particle.tint; // Use the particle's color
                trail.alpha = particle.alpha;
                trail.anchor.set(0.5);
                trail.x = particle.x;
                trail.y = particle.y;
                trail.scale.set(particle.scale.x * 0.9);
                trail.life = 10;
                explosionContainer.addChild(trail);
                this.trails.push(trail);
            }

            update() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    this.addParticleTrail(p);

                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += particleGravity;
                    p.life--;
                    p.alpha = p.life / p.maxLife;

                    // When particle fades out, spawn secondary explosion if not already done and not a secondary
                    const shouldCreateSecondary = this.customSecondaryExplosion !== undefined ? 
                        this.customSecondaryExplosion : 
                        secondaryExplosionsEnabled;
                    
                    if (
                        shouldCreateSecondary &&
                        !this.isSecondary &&
                        !p.hasSpawnedSecondary &&
                        p.life <= 0
                    ) {
                        p.hasSpawnedSecondary = true;
                        
                        if (randomSecondaryTiming) {
                            // Random delay between 0 and 1000ms (1 second)
                            const delay = Math.random() * 1000;
                            // Store particle position for delayed explosion
                            const particleX = p.x;
                            const particleY = p.y;
                            const particleColor = p.tint;
                            setTimeout(() => {
                                explosions.push(new Explosion(particleX, particleY, 0, 0, true, particleColor));
                            }, delay);
                        } else {
                            // Immediate secondary explosion
                            explosions.push(new Explosion(p.x, p.y, 0, 0, true, p.tint)); // Pass individual particle's color
                        }
                    }

                    if (p.life <= 0) {
                        explosionContainer.removeChild(p);
                        this.particles.splice(i, 1);
                    }
                }

                for (let i = this.trails.length - 1; i >= 0; i--) {
                    const t = this.trails[i];
                    t.life--;
                    t.alpha -= 0.04;
                    if (t.alpha <= 0) {
                        explosionContainer.removeChild(t);
                        this.trails.splice(i, 1);
                    }
                }
                return this.particles.length > 0 || this.trails.length > 0;
            }
        }

        // Elliptical Explosion Class
        class EllipticalExplosion {
            constructor(x, y, color) {
                this.particles = [];
                this.trails = [];
                this.x = x;
                this.y = y;
                this.color = color;
                this.trailsEnabled = particleTrailsEnabled;
                this.thisLifetime = particleLifetime;
                
                // Generate random rotation angle for the ellipse
                this.rotationAngle = Math.random() * Math.PI * 2;
                
                this.initParticles();
            }

            initParticles() {
                const count = particleCount;
                
                for (let i = 0; i < count; i++) {
                    const p = new PIXI.Sprite(explosionParticleTexture);
                    p.tint = this.color;
                    p.anchor.set(0.5);
                    p.x = this.x;
                    p.y = this.y;
                    
                    // Generate angle for full 360¬∞ coverage
                    const angle = (i / count) * Math.PI * 2; // Evenly distribute angles
                    
                    // Use consistent speed for clean elliptical shape
                    const baseSpeed = (maxExplosionSpeed + minExplosionSpeed) / 2;
                    
                    // Create narrower elliptical pattern
                    const ellipticalFactorX = 2.0; // Major axis (longer)
                    const ellipticalFactorY = 0.4; // Minor axis (much shorter for narrow ellipse)
                    
                    // Calculate velocity components before rotation
                    const vxLocal = Math.cos(angle) * baseSpeed * ellipticalFactorX;
                    const vyLocal = Math.sin(angle) * baseSpeed * ellipticalFactorY;
                    
                    // Apply rotation to the velocity components
                    p.vx = vxLocal * Math.cos(this.rotationAngle) - vyLocal * Math.sin(this.rotationAngle);
                    p.vy = vxLocal * Math.sin(this.rotationAngle) + vyLocal * Math.cos(this.rotationAngle);
                    
                    p.scale.set(0.5);
                    p.life = this.thisLifetime;
                    p.maxLife = this.thisLifetime;
                    p.hasSpawnedSecondary = false;
                    explosionContainer.addChild(p);
                    this.particles.push(p);
                }
            }

            addParticleTrail(particle) {
                if (!this.trailsEnabled) return;
                const trail = new PIXI.Sprite(explosionTrailTexture);
                trail.tint = particle.tint;
                trail.alpha = particle.alpha;
                trail.anchor.set(0.5);
                trail.x = particle.x;
                trail.y = particle.y;
                trail.scale.set(particle.scale.x * 0.9);
                trail.life = 10;
                explosionContainer.addChild(trail);
                this.trails.push(trail);
            }

            update() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    this.addParticleTrail(p);

                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += particleGravity;
                    p.life--;
                    p.alpha = p.life / p.maxLife;

                    // Secondary explosions
                    if (
                        secondaryExplosionsEnabled &&
                        !p.hasSpawnedSecondary &&
                        p.life <= 0
                    ) {
                        p.hasSpawnedSecondary = true;
                        
                        if (randomSecondaryTiming) {
                            const delay = Math.random() * 1000;
                            const particleX = p.x;
                            const particleY = p.y;
                            const particleColor = p.tint;
                            setTimeout(() => {
                                explosions.push(new Explosion(particleX, particleY, 0, 0, true, particleColor));
                            }, delay);
                        } else {
                            explosions.push(new Explosion(p.x, p.y, 0, 0, true, p.tint));
                        }
                    }

                    if (p.life <= 0) {
                        explosionContainer.removeChild(p);
                        this.particles.splice(i, 1);
                    }
                }

                for (let i = this.trails.length - 1; i >= 0; i--) {
                    const t = this.trails[i];
                    t.life--;
                    t.alpha -= 0.04;
                    if (t.alpha <= 0) {
                        explosionContainer.removeChild(t);
                        this.trails.splice(i, 1);
                    }
                }
                return this.particles.length > 0 || this.trails.length > 0;
            }
        }

        // Sparkle Cloud Class
        class SparkleCloud {
            constructor(x, y, count = 120) {
                this.sparkles = [];
                for (let i = 0; i < count; i++) {
                    const s = new PIXI.Sprite(explosionParticleTexture);
                    s.tint = 0xFFFFFF;
                    s.anchor.set(0.5);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 0.7 + 0.2; // very slow for cloud
                    s.vx = Math.cos(angle) * speed;
                    s.vy = Math.sin(angle) * speed;
                    
                    // Position sparkles as if they've already traveled for 40 frames
                    const startRadius = 40 * speed; // distance they would have traveled in 40 frames
                    s.x = x + Math.cos(angle) * startRadius;
                    s.y = y + Math.sin(angle) * startRadius;
                    
                    s.life = 2 * (80 + Math.random() * 40); // double the previous lifetime
                    s.maxLife = s.life;
                    s.scale.set(0.3 + Math.random() * 0.08); // same as secondary
                    s.alpha = 1; // Start visible since they're already spread out
                    explosionContainer.addChild(s);
                    this.sparkles.push(s);
                }
            }
            update() {
                for (let i = this.sparkles.length - 1; i >= 0; i--) {
                    const s = this.sparkles[i];
                    s.x += s.vx;
                    s.y += s.vy;
                    s.life--;

                    // Appear immediately and flicker
                    s.alpha = Math.max(0, (s.life / s.maxLife));
                    // Intense flicker: randomly fully on or off
                    s.alpha = Math.random() < 0.5 ? s.alpha : 0;
                    s.scale.set(0.25 + Math.random() * 0.15);

                    if (s.life <= 0) {
                        explosionContainer.removeChild(s);
                        this.sparkles.splice(i, 1);
                    }
                }
                return this.sparkles.length > 0;
            }
        }

        // Spiral Explosion Class
        class SpiralExplosion {
            constructor(centerX, centerY) {
                this.centerX = centerX;
                this.centerY = centerY;
                this.angle = Math.random() * Math.PI * 2; // Random starting angle (0 to 360 degrees)
                this.radius = 0; // Current spiral radius
                this.frameCount = 0;
                this.active = true;
                this.maxRadius = 50; // Keep spiral within 50 pixels radius
                this.rotationDirection = Math.random() < 0.5 ? 1 : -1; // 50% chance for clockwise (1) or counterclockwise (-1)
                
                // Generate random bright color for this spiral
                this.spiralColor = this.generateBrightColor();
            }
            
            generateBrightColor() {
                // Create bright colors by ensuring high saturation and brightness
                const brightColors = [
                    0xFF0040, // Bright Red
                    0xFF4000, // Red-Orange
                    0xFF8000, // Orange
                    0xFFFF00, // Yellow
                    0x80FF00, // Yellow-Green
                    0x00FF00, // Green
                    0x00FF80, // Green-Cyan
                    0x00FFFF, // Cyan
                    0x0080FF, // Light Blue
                    0x0040FF, // Blue
                    0x4000FF, // Blue-Purple
                    0x8000FF, // Purple
                    0xFF00FF, // Magenta
                    0xFF0080, // Pink
                    0xFFFFFF, // White
                    0xFF6600, // Bright Orange
                    0x66FF00, // Lime Green
                    0x0066FF, // Sky Blue
                    0x6600FF, // Violet
                    0xFF6600  // Another Orange
                ];
                
                return brightColors[Math.floor(Math.random() * brightColors.length)];
            }

            update() {
                if (!this.active) return false;

                this.frameCount++;
                
                // Spawn mini-sparkle explosion every frame
                const x = this.centerX + Math.cos(this.angle) * this.radius;
                const y = this.centerY + Math.sin(this.angle) * this.radius;
                
                // Create mini sparkle explosion with 5 white particles
                this.createMiniSparkleExplosion(x, y);
                
                // Advance spiral: 10 degrees per frame
                this.angle += (10 * Math.PI) / 180 * this.rotationDirection; // Apply rotation direction
                this.radius += 0.4; // Slower radius increase to fit within 50px in 2 seconds
                
                // Stop after about 2 seconds (120 frames) or when we reach max radius
                if (this.radius > this.maxRadius || this.frameCount > 120) {
                    this.active = false;
                    return false;
                }
                
                return true;
            }

            createMiniSparkleExplosion(x, y) {
                const particleCount = 10; // Increased from 5 to 10 particles
                
                for (let i = 0; i < particleCount; i++) {
                    const p = new PIXI.Sprite(explosionParticleTexture);
                    p.tint = this.spiralColor; // Use the spiral's random bright color
                    p.anchor.set(0.5);
                    p.x = x;
                    p.y = y;
                    
                    // Random direction and speed for mini explosion
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 1.5 + 0.3; // Reduced explosion size (was 2 + 0.5)
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    
                    p.scale.set(0.3); // Small particles
                    p.life = 30; // Short lifetime
                    p.maxLife = 30;
                    p.hasTrails = false; // No trails for spiral particles
                    
                    explosionContainer.addChild(p);
                    
                    // Add to sparkle cloud system for management
                    if (!this.particles) this.particles = [];
                    this.particles.push(p);
                }
            }

            updateParticles() {
                if (!this.particles) return true;
                
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += particleGravity * 0.5; // Reduced gravity for mini particles
                    p.life--;
                    
                    // Base alpha based on lifetime
                    const baseAlpha = p.life / p.maxLife;
                    
                    // Add flickering effect: randomly fully on or off
                    p.alpha = Math.random() < 0.5 ? baseAlpha : 0;
                    
                    // Add slight scale variation for extra sparkle effect
                    p.scale.set(0.25 + Math.random() * 0.1);
                    
                    if (p.life <= 0) {
                        explosionContainer.removeChild(p);
                        this.particles.splice(i, 1);
                    }
                }
                
                return this.particles.length > 0 || this.active;
            }
        }

        // Management systems
        const activeRockets = [];
        const activeEllipticalExplosions = [];
        const activeSpiralExplosions = [];
        const fadingTrails = [];
        const explosions = [];
        const sparkleClouds = [];

        function launchRocket() {
            const x = Math.random() * app.screen.width;
            const targetY = Math.random() * app.screen.height * 0.6;
            activeRockets.push(new Rocket(x, targetY));
        }

        function createEllipticalExplosion() {
            const centerX = app.screen.width / 2;
            const centerY = app.screen.height / 2;
            
            // Use only silver or gold colors
            const colors = [0xC0C0C0, 0xFFD700]; // Silver and Gold
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            // Create the elliptical explosion at center screen
            activeEllipticalExplosions.push(new EllipticalExplosion(centerX, centerY, color));
        }

        function createSpiralExplosion() {
            const centerX = app.screen.width / 2;
            const centerY = app.screen.height / 2;
            
            // Create the spiral explosion starting from center screen
            activeSpiralExplosions.push(new SpiralExplosion(centerX, centerY));
        }

        function createSpiralCloud() {
            const centerX = app.screen.width / 2;
            const centerY = app.screen.height / 2;
            const cloudRadius = 100; // 100 pixel radius for the cloud
            const spiralCount = 16; // 16 spiral explosions
            
            // Create 16 spiral explosions randomly distributed within the 100 pixel circle
            for (let i = 0; i < spiralCount; i++) {
                // Generate random angle and distance within the circle
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * cloudRadius; // Random distance from 0 to cloudRadius
                
                // Calculate position within the circle
                const x = centerX + Math.cos(angle) * distance;
                const y = centerY + Math.sin(angle) * distance;
                
                // Create spiral explosion at the calculated position
                activeSpiralExplosions.push(new SpiralExplosion(x, y));
            }
        }

        // Timeline-based show controller
        class TimelineController {
            constructor() {
                this.isRunning = false;
                this.startTime = 0;
                this.currentShow = null;
                this.eventIndex = 0;
            }

            startShow(showData) {
                this.currentShow = showData;
                this.isRunning = true;
                this.startTime = Date.now();
                this.eventIndex = 0;
                console.log('Starting fireworks show:', showData.name);
                
                // Disable auto fire during show
                autoFireEnabled = false;
                if (autoFireToggle) {
                    autoFireToggle.checked = false;
                }
            }

            stopShow() {
                this.isRunning = false;
                this.currentShow = null;
                this.eventIndex = 0;
                console.log('Stopped fireworks show');
            }

            update() {
                if (!this.isRunning || !this.currentShow) return;

                const elapsedTime = Date.now() - this.startTime; // Keep in milliseconds
                const events = this.currentShow.events;

                // Process all events that should have triggered by now
                while (this.eventIndex < events.length && events[this.eventIndex].time <= elapsedTime) {
                    this.processEvent(events[this.eventIndex]);
                    this.eventIndex++;
                }

                // Check if show is complete
                if (this.eventIndex >= events.length) {
                    this.stopShow();
                }
            }

            processEvent(event) {
                console.log('Processing event:', event);
                
                switch (event.type) {
                    case 'rockets':
                        this.launchRockets(event);
                        break;
                    case 'sparkles':
                        this.createSparkles(event);
                        break;
                    case 'pause':
                        // Pause events are handled by the timeline itself
                        break;
                    default:
                        console.warn('Unknown event type:', event.type);
                }
            }

            launchRockets(event) {
                const count = event.count || 1;
                const spread = event.spread || app.screen.width;
                const startX = event.startX || (app.screen.width - spread) / 2;
                
                for (let i = 0; i < count; i++) {
                    let x;
                    if (count === 1) {
                        x = startX + spread / 2;
                    } else {
                        x = startX + (i * spread) / (count - 1);
                    }
                    
                    const targetY = event.targetY || Math.random() * app.screen.height * 0.6;
                    
                    // Create rocket with custom properties
                    const rocket = new Rocket(x, targetY);
                    
                    // Apply event-specific properties
                    if (event.particleColor !== undefined) {
                        rocket.customParticleColor = this.parseColor(event.particleColor);
                    }
                    if (event.particleCount !== undefined) {
                        rocket.customParticleCount = event.particleCount;
                    }
                    if (event.rocketSpeed !== undefined) {
                        rocket.customRocketSpeed = event.rocketSpeed;
                    }
                    if (event.trailEnabled !== undefined) {
                        rocket.customTrailEnabled = event.trailEnabled;
                    }
                    if (event.secondaryExplosion !== undefined) {
                        rocket.customSecondaryExplosion = event.secondaryExplosion;
                    }
                    
                    activeRockets.push(rocket);
                }
            }

            createSparkles(event) {
                const x = event.x || Math.random() * app.screen.width;
                const y = event.y || Math.random() * app.screen.height;
                const count = event.count || 50;
                
                sparkleClouds.push(new SparkleCloud(x, y, count));
            }

            parseColor(colorValue) {
                if (typeof colorValue === 'string') {
                    // Handle hex string like "0xFFFFFF"
                    if (colorValue.startsWith('0x')) {
                        return parseInt(colorValue, 16);
                    }
                    // Handle regular hex string like "#FFFFFF"
                    if (colorValue.startsWith('#')) {
                        return parseInt(colorValue.substring(1), 16);
                    }
                }
                // If it's already a number, return as is
                return colorValue;
            }
        }

        // Create timeline controller instance
        const timelineController = new TimelineController();

        // Better performance monitoring functions
        function estimateSystemLoad() {
            // Count current particles
            let totalParticles = 0;
            explosions.forEach(explosion => {
                totalParticles += explosion.particles.length;
                totalParticles += explosion.trails.length;
            });
            sparkleClouds.forEach(cloud => {
                totalParticles += cloud.sparkles.length;
            });
            activeRockets.forEach(rocket => {
                totalParticles += rocket.activeTrails.length;
            });
            fadingTrails.forEach(trail => {
                totalParticles += trail.activeTrails.length;
            });
            totalParticles += activeRockets.length;

            // Estimate CPU load based on FPS degradation and particle count
            let cpuLoad = 0;
            if (fps > 0) {
                // CPU load increases as FPS drops below 60, and with particle count
                const fpsRatio = Math.max(0, (60 - fps) / 60);
                const particleLoad = Math.min(50, totalParticles / 100); // Max 50% from particles
                cpuLoad = Math.min(100, fpsRatio * 50 + particleLoad);
            }

            // Estimate GPU load based on particle density and rendering complexity
            let gpuLoad = 0;
            if (app.renderer.type === PIXI.RENDERER_TYPE.WEBGL) {
                // For WebGL, estimate based on particle count and screen fill
                const screenArea = app.screen.width * app.screen.height;
                const particleDensity = totalParticles / (screenArea / 1000000); // particles per megapixel
                const baseLoad = Math.min(30, totalParticles / 200); // Base load from particle count
                const densityLoad = Math.min(40, particleDensity * 20); // Additional load from density
                const fpsLoad = Math.max(0, (60 - fps) / 2); // FPS impact on GPU
                gpuLoad = Math.min(100, baseLoad + densityLoad + fpsLoad);
            } else {
                // Canvas renderer is more CPU intensive
                gpuLoad = Math.min(100, totalParticles / 50);
            }

            return {
                cpu: Math.round(cpuLoad),
                gpu: Math.round(gpuLoad)
            };
        }

        // Main loop
        app.ticker.add(() => {
            // FPS calculation
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fps = Math.round(frameCount * 1000 / (now - lastTime));
                fpsDisplay.textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastTime = now;
                
                // Update performance displays (once per second)
                const systemLoad = estimateSystemLoad();
                cpuLoadDisplay.textContent = `CPU: ${systemLoad.cpu}%`;
                gpuLoadDisplay.textContent = `GPU: ${systemLoad.gpu}%`;
            }

            // Update particle count display
            let totalParticles = 0;
            explosions.forEach(explosion => {
                totalParticles += explosion.particles.length;
                totalParticles += explosion.trails.length;
            });
            sparkleClouds.forEach(cloud => {
                totalParticles += cloud.sparkles.length;
            });
            activeRockets.forEach(rocket => {
                totalParticles += rocket.activeTrails.length;
            });
            activeEllipticalExplosions.forEach(ellipticalExplosion => {
                totalParticles += ellipticalExplosion.particles.length;
                totalParticles += ellipticalExplosion.trails.length;
            });
            activeSpiralExplosions.forEach(spiralExplosion => {
                if (spiralExplosion.particles) {
                    totalParticles += spiralExplosion.particles.length;
                }
            });
            fadingTrails.forEach(trail => {
                totalParticles += trail.activeTrails.length;
            });
            totalParticles += activeRockets.length; // Count the rockets themselves
            particleCountDisplay.textContent = `Particles: ${totalParticles}`;

            // Update timeline controller
            timelineController.update();
            
            // Update rockets
            for (let i = activeRockets.length - 1; i >= 0; i--) {
                if (!activeRockets[i].update()) {
                    fadingTrails.push(activeRockets[i]);
                    
                    // Prepare custom properties for explosion
                    const customProperties = {};
                    if (activeRockets[i].customParticleCount !== undefined) {
                        customProperties.particleCount = activeRockets[i].customParticleCount;
                    }
                    if (activeRockets[i].customParticleColor !== undefined) {
                        customProperties.particleColor = activeRockets[i].customParticleColor;
                    }
                    if (activeRockets[i].customTrailEnabled !== undefined) {
                        customProperties.trailEnabled = activeRockets[i].customTrailEnabled;
                    }
                    if (activeRockets[i].customSecondaryExplosion !== undefined) {
                        customProperties.secondaryExplosion = activeRockets[i].customSecondaryExplosion;
                    }
                    
                    createExplosionByPayload(
                        activeRockets[i].sprite.x,
                        activeRockets[i].sprite.y,
                        activeRockets[i].vx,
                        activeRockets[i].vy,
                        customProperties
                    );
                    activeRockets.splice(i, 1);
                }
            }

            // Update fading trails
            for (let i = fadingTrails.length - 1; i >= 0; i--) {
                if (!fadingTrails[i].updateTrailsOnly()) {
                    fadingTrails.splice(i, 1);
                }
            }

            // Update explosions
            for (let i = explosions.length - 1; i >= 0; i--) {
                if (!explosions[i].update()) {
                    explosions.splice(i, 1);
                }
            }

            // Update elliptical explosions
            for (let i = activeEllipticalExplosions.length - 1; i >= 0; i--) {
                if (!activeEllipticalExplosions[i].update()) {
                    activeEllipticalExplosions.splice(i, 1);
                }
            }

            // Update spiral explosions
            for (let i = activeSpiralExplosions.length - 1; i >= 0; i--) {
                // Update spiral position and spawn new mini explosions
                const spiralActive = activeSpiralExplosions[i].update();
                // Update existing particles from this spiral
                const particlesActive = activeSpiralExplosions[i].updateParticles();
                
                if (!spiralActive && !particlesActive) {
                    activeSpiralExplosions.splice(i, 1);
                }
            }

            // Update sparkle clouds
            for (let i = sparkleClouds.length - 1; i >= 0; i--) {
                if (!sparkleClouds[i].update()) {
                    sparkleClouds.splice(i, 1);
                }
            }
        });

        // Auto-launch rockets when enabled (using dynamic interval)
        let lastAutoFireTime = Date.now();
        function checkAutoFire() {
            const currentTime = Date.now();
            const intervalMs = parseFloat(document.getElementById('autoFireIntervalSlider').value) * 1000;
            
            if (autoFireEnabled && (currentTime - lastAutoFireTime) >= intervalMs) {
                if (burstModeEnabled) {
                    // Fire multiple rockets in a burst
                    for (let i = 0; i < burstRocketCount; i++) {
                        launchRocket();
                    }
                } else {
                    // Fire single rocket
                    launchRocket();
                }
                lastAutoFireTime = currentTime;
            }
        }
        
        setInterval(checkAutoFire, 50); // Check frequently for responsive interval changes

        console.log('=== SETTING UP CLICK HANDLERS ===');
        
        // Click to create explosions or fire rockets
        app.stage.eventMode = 'static';
        app.stage.on('pointerdown', (e) => {
            console.log('Click detected! Auto fire enabled:', autoFireEnabled, 'Burst mode enabled:', burstModeEnabled);
            if (autoFireEnabled) {
                // When auto fire is enabled, clicking creates explosions using payload system
                console.log('Creating explosion at:', e.global.x, e.global.y);
                createExplosionByPayload(e.global.x, e.global.y);
            } else {
                // When auto fire is disabled, clicking fires rockets
                if (burstModeEnabled) {
                    // Fire multiple rockets in a burst
                    console.log('Launching burst of', burstRocketCount, 'rockets');
                    for (let i = 0; i < burstRocketCount; i++) {
                        launchRocket();
                    }
                } else {
                    // Fire single rocket
                    console.log('Launching single rocket');
                    launchRocket();
                }
            }
        });
        console.log('=== PIXI CLICK HANDLER SET UP ===');

        // Backup click handler on canvas element
        app.view.addEventListener('click', (e) => {
            console.log('Canvas click detected! Auto fire enabled:', autoFireEnabled, 'Burst mode enabled:', burstModeEnabled);
            const rect = app.view.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (autoFireEnabled) {
                console.log('Creating explosion at:', x, y);
                createExplosionByPayload(x, y);
            } else {
                // When auto fire is disabled, clicking fires rockets
                if (burstModeEnabled) {
                    // Fire multiple rockets in a burst
                    console.log('Launching burst of', burstRocketCount, 'rockets');
                    for (let i = 0; i < burstRocketCount; i++) {
                        launchRocket();
                    }
                } else {
                    // Fire single rocket
                    console.log('Launching single rocket');
                    launchRocket();
                }
            }
        });

        // Right-click handler for sparkle cloud
        app.view.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const rect = app.view.getBoundingClientRect();
            const centerX = e.clientX - rect.left;
            const centerY = e.clientY - rect.top;
            const radius = 120; // Max distance from center
            const numClouds = 32;
            for (let i = 0; i < numClouds; i++) {
                // Random angle and random radius (uniform distribution in circle)
                const angle = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()) * radius;
                const x = centerX + Math.cos(angle) * r;
                const y = centerY + Math.sin(angle) * r;
                sparkleClouds.push(new SparkleCloud(x, y));
            }
        });

        // Handle resize
        window.addEventListener('resize', () => {
            app.renderer.resize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>